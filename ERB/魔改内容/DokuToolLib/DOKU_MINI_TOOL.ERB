@DOKU_PRINT_COLOR(ARGS,ARG,ARG:1=0)
#FUNCTIONS
#LOCALSIZE 1
#LOCALSSIZE 1
CALLF DOKU_SL_COLOR("S")
SIF ARG:1 < 0
CLEARLINE -1*ARG:1
SETCOLOR ARG
PRINTFORMS ARGS
IF ARG:1>0
FOR LOCAL,0,ARG:1
PRINTL
NEXT
ENDIF
CALLF DOKU_SL_COLOR("L")
RETURNF

@DOKU_COLOR_GET(ARG)
#DIM TEMP_COLOR
VARSET RESULTS
CALLF DOKU_SL_COLOR("S")
IF CFLAG:ARG:口上セレクタ
TRYCALLFORM M_KOJO_K{ARG}_{CFLAG:ARG:口上セレクタ}
ELSE
TRYCALLFORM M_KOJO_K{ARG}
ENDIF
TRYCCALLFORM M_KOJO%RESULTS%_COLOR_K{ARG}
CATCH
CALLF DOKU_SL_COLOR("L")
RETURN 0
ENDCATCH
TEMP_COLOR = GETCOLOR()
CALLF DOKU_SL_COLOR("L")
RETURN TEMP_COLOR

@DOKU_COLOR_SET_PRINT(ARG,ARGS)
CALLF DOKU_SL_COLOR("S")
CALL DOKU_COLOR_GET(ARG)
IF RESULT
SETCOLOR RESULT
ELSE
RESETCOLOR
ENDIF
PRINTFORML %ARGS%
CALLF DOKU_SL_COLOR("L")
RETURN 0

@DOKU_SETCOLOR(ARG,ARGS)
;设置口上色
IF ARGS == ""
TRYCALLFORM M_KOJO_COLOR_K{ARG}
ELSE
TRYCALLFORM M_KOJO_%ARGS%_COLOR_K{ARG}
ENDIF
RETURN 0

@DOKU_SL_COLOR(ARGS)
#FUNCTION
#LOCALSSIZE 1
#DIM TAILHERE
#DIM TEMP_RESULT
TEMP_RESULT = 0
;栈式颜色存储，栈大小499
SELECTCASE ARGS
CASE "S","SAVE"
LOCAL:TAILHERE = GETCOLOR()
TEMP_RESULT = LOCAL:TAILHERE
TAILHERE ++
RESETCOLOR
CASE "L","LOAD"
SIF TAILHERE <0
THROW
TAILHERE --
SETCOLOR LOCAL:TAILHERE
TEMP_RESULT = LOCAL:TAILHERE
LOCAL:TAILHERE = -1
CASEELSE
VARSET LOCAL,-1
TEMP_RESULT = -1
ENDSELECT
RETURNF TEMP_RESULT

@DOKU_RESET_CHARA(ARG)
ADDCHARA ARG
SWAPCHARA ARG,(CHARANUM-1)
DELCHARA (CHARANUM-1)
RETURN 0

@DOKU_NUM_MATCH_SLASH_SPLIT(ARG,ARGS)
#DIMS STR_ARRAY_USED_HERE,2
;ARGS为"A~B"是匹配闭区间[A,B]内的所有；为A/B/C是匹配A或B或C。可共存，如"A/B~C/D"
VARSET LOCALS
VARSET STR_ARRAY_USED_HERE
SPLIT ARGS:0,"/",LOCALS
LOCAL:0=-1
LOCAL:1=RESULT
VARSET RESULT
WHILE 1
LOCAL:0 ++
SIF LOCAL:0>=LOCAL:1
BREAK
SPLIT LOCALS:(LOCAL:0),"~",STR_ARRAY_USED_HERE
ISNUMERIC STR_ARRAY_USED_HERE:0
SIF !RESULT
CONTINUE
TOINT STR_ARRAY_USED_HERE:0
IF RESULT == 0
SIF ARG == RESULT
RETURN 1
SIF ARG<RESULT
CONTINUE
ISNUMERIC STR_ARRAY_USED_HERE:1
SIF !RESULT
CONTINUE
TOINT STR_ARRAY_USED_HERE:1
SIF ARG>RESULT
CONTINUE
RETURN 1
CONTINUE
ELSE
SIF ARG == RESULT
RETURN 1
SIF ARG<RESULT
CONTINUE
ISNUMERIC STR_ARRAY_USED_HERE:1
SIF !RESULT
CONTINUE
TOINT STR_ARRAY_USED_HERE:1
SIF ARG>RESULT
CONTINUE
RETURN 1
ENDIF
WEND
RETURN 0

@DOKU_NUM_MATCH_SLASH_SPLIT_F(ARG,ARGS)
#FUNCTION
#LOCALSIZE 2
#DIMS STR_ARRAY_USED_HERE,2
;ARGS为"A~B"是匹配闭区间[A,B]内的所有；为A/B/C是匹配A或B或C。可共存，如"A/B~C/D"
;这个是上面的非式中函数的式中函数版
VARSET LOCALS
VARSET STR_ARRAY_USED_HERE
SPLIT ARGS:0,"/",LOCALS
LOCAL:0=-1
LOCAL:1=RESULT
VARSET RESULT
WHILE 1
LOCAL:0 ++
SIF LOCAL:0>=LOCAL:1
BREAK
SPLIT LOCALS:(LOCAL:0),"~",STR_ARRAY_USED_HERE
ISNUMERIC STR_ARRAY_USED_HERE:0
SIF !RESULT
CONTINUE
TOINT STR_ARRAY_USED_HERE:0
IF RESULT == 0
SIF ARG == RESULT
RETURNF 1
SIF ARG<RESULT
CONTINUE
ISNUMERIC STR_ARRAY_USED_HERE:1
SIF !RESULT
CONTINUE
TOINT STR_ARRAY_USED_HERE:1
SIF ARG>RESULT
CONTINUE
RETURNF 1
CONTINUE
ELSE
SIF ARG == RESULT
RETURNF 1
SIF ARG<RESULT
CONTINUE
ISNUMERIC STR_ARRAY_USED_HERE:1
SIF !RESULT
CONTINUE
TOINT STR_ARRAY_USED_HERE:1
SIF ARG>RESULT
CONTINUE
RETURNF 1
ENDIF
WEND
RETURNF 0

@DOKU_KM_RENEW_TARGET(ARG)
;优化用函数，用于替代简单粗暴的INFO_RENEW_TARGET来更新target，防止其他人的FLAGSETTING被反复执行
;ARG是外部输入的角色编号。只要在自己的flagset里做好反重复执行就好了
;KM的意思是KOJO_MESSAGE
VARSET LOCAL
IF !ARG
;为了配合DOKU_MOVE对玩家进行移动的情况
CALL INFO_RENEW_TARGET
RETURN 1
ENDIF
TARGET:0 = 0
CALL TARGETSET_CHACK("")
LOCAL = FLAG:7
FLAG:7 = 1
CALL KOJO_MESSAGE_SEND("EVENT",666666, ARG,-1,-1)
TFLAG:104 = TARGET
FLAG:7 = LOCAL
;GRAVITY有别的用处
RETURN 1

@DOKU_KM_RENEW_AND_SET_TARGET(ARG)
IF CFLAG:ARG:300 != CFLAG:0:300
CALL DOKU_KM_RENEW_TARGET(ARG)
RETURN 1
ENDIF

TARGET = ARG
LOCAL = FLAG:7
FLAG:7 = 1
CALL KOJO_MESSAGE_SEND("EVENT",666666, ARG,-1,-1)
FLAG:7 = LOCAL
TFLAG:104 = ARG
RETURN 1

@DOKU_SET_SLEEP(ARG,ARG:1)
IF ARG:1
CFLAG:ARG:313 = 1
CFLAG:ARG:300 = CFLAG:ARG:311
CFLAG:ARG:12 = MAIN_MAP
TCVAR:ARG:149 = 66 ;睡眠深度
TCVAR:ARG:151 = 66 ;疲劳度
SETBIT CFLAG:ARG:700, 0
CLEARBIT CFLAG:ARG:700, 1
ELSE
CFLAG:ARG:313 = 0 ;是否睡眠中
TCVAR:ARG:149 = 0 ;睡眠深度
TCVAR:ARG:151 = 0 ;疲劳度
SETBIT CFLAG:ARG:700, 0
CLEARBIT CFLAG:ARG:700, 1
ENDIF
RETURN 1

@DOKU_SAY(ARGS,COLOR = -1)
#DIM COLOR
;我受够了。「」这对符号。
;↑然后发现用这个会显著降低码字效率
ARGS '= @"「%ARGS%」"
IF COLOR >= 0
CALLF DOKU_SL_COLOR("S")
SETCOLOR COLOR
PRINTFORMSL ARGS
CALLF DOKU_SL_COLOR("L")
ELSE
PRINTFORMSL ARGS
ENDIF
RETURN 0

@DOKU_SAYL(ARGS,COLOR=-1)
;有时候会按着写PRINT的习惯把SAYW改成SAYL
#DIM COLOR
CALL DOKU_SAY(ARGS,COLOR)
RETURN 0

@DOKU_SAYW(ARGS,COLOR = -1)
#DIM COLOR
ARGS '= @"「%ARGS%」"
IF COLOR >= 0
CALLF DOKU_SL_COLOR("S")
SETCOLOR COLOR
PRINTFORMSW ARGS
CALLF DOKU_SL_COLOR("L")
ELSE
PRINTFORMSW ARGS
ENDIF
RETURN 0

@DOKU_STR_OP(STR_INPUT,ARGS,ARGS:1)
;利用字符串存储一些属性的工具
#DIMS TEMP_STR_ARRAY,99
#DIMS REF STR_INPUT
#DIMS CHECK_STR
VARSET LOCALS
VARSET LOCAL
VARSET CHECK_STR
VARSET TEMP_STR_ARRAY
VARSET RESULTS
VARSET RESULT
SELECTCASE ARGS
CASE "GET","G"
IF ARGS:1 != ""
	CHECK_STR '= ARGS:1
	SPLIT STR_INPUT,"/",LOCALS
	LOCAL:1 = RESULT
	FOR LOCAL,0,LOCAL:1
		SPLIT LOCALS:LOCAL,":",TEMP_STR_ARRAY
		IF TEMP_STR_ARRAY:0 == CHECK_STR && TEMP_STR_ARRAY:1 != ""
		RESULTS += TEMP_STR_ARRAY:1
		RESULTS += "/"
		ENDIF
	NEXT
ELSE
	RESULTS '= STR_INPUT
	RETURN 0
ENDIF

CASE "CHECK","C"
SPLIT ARGS:1,"/",TEMP_STR_ARRAY
SPLIT STR_INPUT,TEMP_STR_ARRAY:1,LOCALS
;由于格式一定是xxx/xx/xxxx/，这么split最后一定多一个/
RETURN RESULT > 1

CASE "SET","S"
SPLIT ARGS:1,"/",LOCALS
STR_INPUT '= ""
FOR LOCAL,0,RESULT
SIF LOCALS:LOCAL == ""
BREAK
STR_INPUT += LOCALS:LOCAL
STR_INPUT += "/"
NEXT

CASE "ADD","A"
SPLIT ARGS:1,"/",LOCALS
FOR LOCAL,0,RESULT
SIF LOCALS:LOCAL == ""
BREAK
STR_INPUT += LOCALS:LOCAL
STR_INPUT += "/"
NEXT

CASE "DEL","D"
SPLIT ARGS:1,"/",LOCALS
LOCAL:1 = 0
FOR LOCAL,0,RESULT
	SPLIT STR_INPUT,@"%LOCALS:LOCAL%/",TEMP_STR_ARRAY
	SIF RESULT>1
	LOCAL:1 ++
	STR_INPUT '= TEMP_STR_ARRAY:0
	STR_INPUT += TEMP_STR_ARRAY:1
NEXT
RETURN LOCAL:1

CASE "CLEAR_ERROR","CLEAR","CE"
SPLIT STR_INPUT,"/",LOCALS
STR_INPUT '= ""
FOR LOCAL,0,RESULT
SIF LOCALS:LOCAL == ""
BREAK
SPLIT LOCALS:LOCAL,":",TEMP_STR_ARRAY
SIF TEMP_STR_ARRAY:1 == "" || TEMP_STR_ARRAY:0 == ""
LOCALS:LOCAL '= ""

IF LOCALS:LOCAL != ""
STR_INPUT += LOCALS:LOCAL
STR_INPUT += "/"
ENDIF
NEXT


ENDSELECT

RETURN 0

@DOKU_PRINT_GRADIENT(ARGS,ARG,ARG:1)
#FUNCTION
CALLF DOKU_SL_COLOR("S")
VARSET LOCALS
SPLIT ARGS,"/",LOCALS
LOCAL:1 = MAX(1,RESULT)
LOCAL:2 = (ARG/0x10000-ARG:1/0x10000)/LOCAL:1
LOCAL:3 = (ARG%0x10000/0x100-ARG:1%0x10000/0x100)/LOCAL:1
LOCAL:4 = (ARG%0x100-ARG:1%0x100)/LOCAL:1

LOCAL:5 = ARG:1/0x10000
LOCAL:6 = ARG:1%0x10000/0x100
LOCAL:7 = ARG:1%0x100

SETCOLOR ARG
PRINTFORMS LOCALS
FOR LOCAL,1,LOCAL:1
SETCOLOR LOCAL:5 + (LOCAL:1-LOCAL-1)*LOCAL:2,LOCAL:6+(LOCAL:1-LOCAL-1)*LOCAL:3,LOCAL:7+(LOCAL:1-LOCAL-1)*LOCAL:4
PRINTFORMS LOCALS:LOCAL
NEXT
CALLF DOKU_SL_COLOR("L")
RETURNF 0

@DOKU_PRINTL_GRADIENT(ARGS,ARG,ARG:1)
CALLF DOKU_PRINT_GRADIENT(ARGS,ARG,ARG:1)
PRINTL 
RETURN 0

@DOKU_PRINTW_GRADIENT(ARGS,ARG,ARG:1)
CALLF DOKU_PRINT_GRADIENT(ARGS,ARG,ARG:1)
PRINTW 
RETURN 0

@DOKU_PRINT_WITH_COLOR(ARGS,ARG)
#FUNCTION
CALLF DOKU_SL_COLOR("S")
SETCOLOR ARG
PRINTFORMS ARGS
CALLF DOKU_SL_COLOR("L")
RETURNF 0

@DOKU_PRINTL_WITH_COLOR(ARGS,ARG)
CALLF DOKU_PRINT_WITH_COLOR(ARGS,ARG)
PRINTL 
RETURN 0

@DOKU_PRINTW_WITH_COLOR(ARGS,ARG)
CALLF DOKU_PRINT_WITH_COLOR(ARGS,ARG)
PRINTW 
RETURN 0

