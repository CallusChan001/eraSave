@DOKU_ULTRA_ASK_M(ARGS,ARGS:1="")
;COLOR_SL外置
CALLF DOKU_SL_COLOR("S")
CALL DOKU_ULTRA_ASK_M_CORE(ARGS,ARGS:1)
LOCAL = RESULT
CALLF DOKU_SL_COLOR("L")
RETURN LOCAL

@DOKU_ULTRA_ASK_M_CORE(ARGS,ARGS:1="")
#LOCALSSIZE 1000
;输入内容ARGS形如：@"选项内容/:/{控制参数数字变量}/*/选项内容/:/%控制参数字符串变量%/*/"
;选项内容可能包括实际的输入的内容
;ARGS:1用途待定
#DIM DYNAMIC CURRENT_OPTION_INDEX = 0
#DIM DYNAMIC REAL_RESULT = -1
#DIM DYNAMIC NUM_OF_LINE_TO_CLEAR = 0
#DIM MAX_OPTION_NUM_HERE
#DIM DYNAMIC NUM_OF_FLEE_OPTION = 0

#DIMS TEMP_STR,2
#DIMS TEMP_STRA,2
#DIMS DYNAMIC MATCH_OPTION_STR
#DIMS DYNAMIC MATCH_OPTION_NUM

SPLIT ARGS,"/*/",LOCALS
MAX_OPTION_NUM_HERE = RESULT

SIF LOCALS:0 == ""
RETURN -1 ;只有一个空选项的情况。本来想写THROW但是算了。
SIF MAX_OPTION_NUM_HERE<=0
MAX_OPTION_NUM_HERE = 1
;没有/*/就当只有一个选项来处理

SIF LOCALS:(MAX_OPTION_NUM_HERE-1)==""
MAX_OPTION_NUM_HERE --
;如果字符串尾有/*/那SPLIT最后会有一个空LOCALS，把它去掉
;并不会导致MAX_OPTION_NUM变成0，因为那种情况会在更早的时候RETURN -1

;到此，MAX_OPTION_NUM_HERE表示最终选项数。所以LOCAL是数组下标
;从这里，开始对选项的预处理。如果每次遇上无效INPUT都要重新处理就太蠢了，所以先处理好
MATCH_OPTION_NUM '= "/*/"
;这是下面要用到的神奇妙妙工具


FOR LOCAL,0,MAX_OPTION_NUM_HERE
VARSET TEMP_STR
SPLIT LOCALS:LOCAL,"/:/",TEMP_STR
;SPLIT的结果可能是数字。数字是用来配合变量使用的。
LOCAL:1 = LOCAL - NUM_OF_FLEE_OPTION
LOCALS:LOCAL '= @"{LOCAL:1}"
;现在开始，LOCALS:LOCAL的意义就是选项对应的实际输入了

IF TEMP_STR:0 == ""

NUM_OF_FLEE_OPTION ++
CONTINUE
ENDIF

SELECTCASE TEMP_STR:1
CASE "0","UNABLE"
	;打印选项但不可选的情况
	NUM_OF_LINE_TO_CLEAR ++

	SETCOLOR 0x606060
	PRINTPLAINFORM [%LOCALS:LOCAL%]%TEMP_STR:0%
	RESETCOLOR
	PRINTL 

CASE "1","NORMAL"
	;普通的情况，有HIDE的话可能出现0-1-HIDE-3-4-5这种
	$CASE_1

	MATCH_OPTION_STR += @"%TEMP_STR:0%/:/{LOCAL:0}/*/"
	MATCH_OPTION_NUM += @"%LOCALS:LOCAL%/:/{CURRENT_OPTION_INDEX}/*/"
	;选项内容/:/实际返回值
	;实际输入内容/:/下标

	NUM_OF_LINE_TO_CLEAR ++
	CURRENT_OPTION_INDEX ++

	PRINTBUTTON @"[%LOCALS:LOCAL%]%TEMP_STR:0%",LOCALS:LOCAL
	PRINTL

CASE "2","INVISIBLE","INVIS"

CASE "3","HIDDEN","HIDE"

	MATCH_OPTION_STR += @"%TEMP_STR:0%/:/{LOCAL:0}/*/"
	MATCH_OPTION_NUM += @"%LOCALS:LOCAL%/:/{CURRENT_OPTION_INDEX}/*/"
	;选项内容/:/实际返回值
	;实际输入内容/:/下标

	CURRENT_OPTION_INDEX ++

CASE "4","DYNAMIC" ;严格按照0-1-2-3-4做输入，即使实际是0-1-HIDE-3-4-5，配合HIDE的话是【4-2*HIDE条件】或者【2+2*DYNAMIC条件】
	LOCALS:LOCAL = CURRENT_OPTION_INDEX
	MATCH_OPTION_STR += @"%TEMP_STR:0%/:/{LOCAL:0}/*/"
	MATCH_OPTION_NUM += @"%LOCALS:LOCAL%/:/{CURRENT_OPTION_INDEX}/*/"
	;选项内容/:/实际返回值
	;【实际输入内容】/:/下标

	NUM_OF_LINE_TO_CLEAR ++
	CURRENT_OPTION_INDEX ++

	PRINTBUTTON @"[%LOCALS:LOCAL%]%TEMP_STR:0%",LOCALS:LOCAL
	PRINTL

CASEELSE
;包括不存在控制参数的情况
	SPLIT TEMP_STR:1,"/+/",TEMP_STRA
	SIF TEMP_STRA:0 == "" || TEMP_STRA:1 == ""
	GOTO CASE_1
	
	LOCALS:LOCAL '= TEMP_STRA:1
	
	SELECTCASE TEMP_STRA:0
	CASE "1","STRING","STRING_NORMAL","STR","STR_N"
		$CASEA_1
		;控制参数的形式是【STRING/+/输入内容】，即本选项元素内容为【选项内容/:/STRING/+/输入内容/*/】
		
		
		MATCH_OPTION_STR += @"%TEMP_STR:0%/:/{LOCAL:0}/*/"
		MATCH_OPTION_NUM += @"%LOCALS:LOCAL%/:/{CURRENT_OPTION_INDEX}/*/"
		;选项内容/:/实际返回值
		;【实际输入内容】/:/下标
		
		NUM_OF_LINE_TO_CLEAR ++
		CURRENT_OPTION_INDEX ++

		PRINTBUTTON @"[%LOCALS:LOCAL%]%TEMP_STR:0%",LOCALS:LOCAL
		PRINTL
	
	
	CASE "0","STRING_UNABLE","STR_U"
		NUM_OF_LINE_TO_CLEAR ++

		SETCOLOR 0x606060
		PRINTPLAINFORM [%LOCALS:LOCAL%]%TEMP_STR:0%
		RESETCOLOR
		PRINTL 
	CASE "2","FAKE_STR","FAKE_STRING","F_STR","STR_F"
		;控制参数的形式是【STRING/+/输入内容】，即本选项元素内容为【选项内容/:/STRING/+/输入内容/*/】
		
		MATCH_OPTION_STR += @"%TEMP_STR:0%/:/{LOCAL:0}/*/"
		MATCH_OPTION_NUM += @"{LOCAL:1}/:/{CURRENT_OPTION_INDEX}/*/"
		;选项内容/:/实际返回值
		;实际输入内容/:/下标
		
		NUM_OF_LINE_TO_CLEAR ++
		CURRENT_OPTION_INDEX ++

		PRINTBUTTON @"[{LOCAL:1}|%LOCALS:LOCAL%]%TEMP_STR:0%",@"{LOCAL:1}"
		PRINTL
	CASE "3","COLORFUL_NORMAL","COLOR_NORMAL","COLORFUL_BUTTON","COLOR_BUTTION","COLOR"
		SIF !ISNUMERIC(TEMP_STRA:1)
		GOTO CASEA_1
		
		;它的按钮内容并不是字符串
		LOCALS:LOCAL '= @"{LOCAL:1}"
		
		MATCH_OPTION_STR += @"%TEMP_STR:0%/:/{LOCAL:0}/*/"
		MATCH_OPTION_NUM += @"%LOCALS:LOCAL%/:/{CURRENT_OPTION_INDEX}/*/"
		;选项内容/:/实际返回值
		;实际输入内容/:/下标
		NUM_OF_LINE_TO_CLEAR ++
		CURRENT_OPTION_INDEX ++
		
		SETCOLOR TOINT(TEMP_STRA:1)
		PRINTBUTTON @"[%LOCALS:LOCAL%]%TEMP_STR:0%",LOCALS:LOCAL
		PRINTL
		RESETCOLOR
	CASE "4","CHANGE_REAL_RESULT","CHANGE_RESULT","C_R"
		SIF !ISNUMERIC(TEMP_STRA:1)
		GOTO CASEA_1
		
		;它的按钮内容并不是字符串
		LOCALS:LOCAL '= @"{LOCAL:1}"
		
		MATCH_OPTION_STR += @"%TEMP_STR:0%/:/%TEMP_STRA:1%/*/"
		MATCH_OPTION_NUM += @"%LOCALS:LOCAL%/:/{CURRENT_OPTION_INDEX}/*/"
		;选项内容/:/【实际返回值】
		;实际输入内容/:/下标
		NUM_OF_LINE_TO_CLEAR ++
		CURRENT_OPTION_INDEX ++
		
		PRINTBUTTON @"[%LOCALS:LOCAL%]%TEMP_STR:0%",@"{LOCAL:1}"
		PRINTL
	CASE "5","HIDDEN_STRING","HIDDEN_STR","HIDE_STRING","HIDE_STR","STR_H","H_STR"
		
		MATCH_OPTION_STR += @"%TEMP_STR:0%/:/{LOCAL:0}/*/"
		MATCH_OPTION_NUM += @"%LOCALS:LOCAL%/:/{CURRENT_OPTION_INDEX}/*/"
		;选项内容/:/实际返回值
		;【实际输入内容】/:/下标
		
		CURRENT_OPTION_INDEX ++
	
	CASE "6","UNKNOWN_STR","UNKNOW_STR","U_STR"
		
		MATCH_OPTION_STR += @"%TEMP_STR:0%/:/{LOCAL:0}/*/"
		MATCH_OPTION_NUM += @"%LOCALS:LOCAL%/:/{CURRENT_OPTION_INDEX}/*/"
		;选项内容/:/实际返回值
		;【实际输入内容】/:/下标
		;【按钮文本】
		
		NUM_OF_LINE_TO_CLEAR ++
		CURRENT_OPTION_INDEX ++

		PRINTBUTTON @"[？？？]%TEMP_STR:0%","DokuHunter39"
		PRINTL
	
	CASEELSE
		GOTO CASEA_1
	ENDSELECT
ENDSELECT
NEXT

SPLIT MATCH_OPTION_STR,"/*/",LOCALS
LOCAL:2 = RESULT - 1
;这里LOCALS:0到LOCALS:(RESULT-2)都是实际有效的选项。
;到此，预处理完成
PRINTL 
$INPUT_LOOP
CLEARLINE 1
INPUTS

LOCALS:(LOCAL:2) '= RESULTS

SPLIT MATCH_OPTION_NUM,@"/%LOCALS:(LOCAL:2)%/:/",TEMP_STR
;由于MATCH_OPTION_NUM串一定是/*/XX/:/YY/*/XX/:/YY/*/的形式，这么SPLIT就可以检测输入的结果XX是否存在于串中
;我喜欢用SPLIT而非STRFIND检索，是因为SPLIT的返回值在意义上用途更广泛。谁关心第一个字符串在哪个位置呢？
SIF RESULT <= 1
GOTO INPUT_LOOP

SPLIT TEMP_STR:1,"/*/",TEMP_STR
LOCAL:1 = TOINT(TEMP_STR:0)

SPLIT LOCALS:(LOCAL:1),"/:/",TEMP_STR
REAL_RESULT = TOINT(TEMP_STR:1)

CLEARLINE NUM_OF_LINE_TO_CLEAR + 1
PRINTPLAINFORM [%LOCALS:(LOCAL:2)%]%TEMP_STR:0%
PRINTL
RETURN REAL_RESULT