@USE_DCCS_SET_SELECTCOM
SELECTCOM = TFLAG:3
CALLF DOKUDIM_SELECTCOM(1,TFLAG:3 + 1000*TFLAG:50)
TFLAG:3 = 999
TFLAG:50 = 0
SELECTCOM = 999
RETURN 0

@USE_DCCS(COMF_PRENAME,ARG:0=0,ARGS:0="",ARG:1=0,ARGS:1="",ARG:2=0,ARGS:2="",ARG:3=0,ARGS:3="")
;批量指令管理系统。写在前面的执行成功了、写在后面的就不会执行

;在M_KOJO%口上名%_SUCCESS_COM_K{角色编号}_666666 中 调用

;返回值的意义：
;-666 报错，当作执行失败
;-1 执行失败
;0 正常运行
;1 指令的结果应为失败（应当不增加好感信赖情绪等）。缺少FAIL（失败文本）函数。
;2 指令的结果应为失败（同上）
;3 指令的结果应为失败（同上）。有触发LOOKON函数
[SKIPSTART]
;如果当前回合没有任何有效操作，则通过COM666666模拟原版流程
;此时提供给口上作者的接口区分SCOM和COM
;对于SCOM，MESSAGE函数的格式是：
;DCCS_KOJO_MESSAGE口上名_KX_SCOM_XXX
;例如我在口上本体中写的某个SUCCESS如果是M_KOJO_66_SUCCESS_COM_KX_XXX
;那么我的口上名是_66（@M_KOJO_KX_N或者@M_KOJO_KX里没写，例如初期版，那口上名就是空串）
;那我这个函数就应该写成DCCS_KOJO_MESSAGE_66_SCOM_KX_XXX
;COM的话，把SCOM改成COM就好
;例如DCCS_KOJO_MESSAGE_66_COM_KX_XXX

;下文注释中的XXX都为COMF_PRENAME、KX中的X都为角色编号
;YYY都为指令编号。如果是SCOM，那么其实际值为1000*TFLAG:50

;参数为0，什么都不动（为了让ARG可以直接由条件通过运算来控制）

;参数为1，普通替换（失败=中止）（有口上）（本模块的【核心】功能）
;普通替换时，CALC的返回值为最终COM返回的值
;所以CALC返回负数相当于中止SOURCE计算，返回0也可以和好感信赖修复
;参数为1时提供给口上作者侧的接口：
;DCCS_SUCCESS_XXX_KX_YYY
;DCCS_FAIL_XXX_KX_YYY(ARG)
;DCCS_CALC_XXX_KX_YYY(ARG)
;DCCS_MESS_XXX_KX_YYY(ARG)
;DCCS_MESS_SOURCE_TRIGGER_XXX_KX_YYY

;调用路径：SUCCESS->RESULT为负->FAIL(RESULT)
;SUCCESS->RESULT为正->CALC(RESULT)->RESULT作为最终指令返回值、并作为ARG传给MESS
;额外的、如果存在DCCS_MESS_SOURCE_TRIGGER_XXX_KX_YYY函数，那么MESS将在USE_DCCS_P2中触发

;对于接口SUCCESS，返回负数的时候当作失败处理、返回0的话不加好感信赖、返回正数才是成功执行。


;参数为2，强制中止（中止不出source和好感信赖）
;提供给口上作者侧的接口：
;DCCS_FAIL_XXX_KX_YYY(ARG)


;参数为3，执行指令，但指令结果为0（和MESSAGE配合来修正好感情绪异常增长）
;参数为4，不取对象的执行指令，同上
;参数为3或4时，提供给口上作者侧的接口：
;DCCS_LOOKON_XXX_KX_YYY(ARG)


;参数为5，强制按原版处理，可以有口上
;提供给口上作者侧的接口：
;DCCS_MESS_XXX_KX_YYY(ARG)
[SKIPEND]
#DIMS COMF_PRENAME
CALLF DOKU_SL_COLOR("S")
CALL DOKU_COMF_CTRL_SYS(COMF_PRENAME,ARG:0-1,ARGS:0,ARG:1-1,ARGS:1,ARG:2-1,ARGS:2,ARG:3-1,ARGS:3)

IF RESULT >= 0
	LOCAL = RESULT
	CALLF DOKUDIM_COMF_HAVE_CALLED(DOKUDIM_REAL_TARGET(),1,LOCAL+1)
	;不走666666的自动补指令、且不执行之后的指令

	PREVCOM = 999
	
	SELECTCASE LOCAL
	CASE 0
		;正常执行了替换后的指令，当然已经设置好了RESULT
	CASE 1
		;FAIL，但没有FAIL_MESS
		CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,-1)
	CASE 2
		;FAIL
		SIF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET()) >= 0
		CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,-1)
	CASE 3
		;SOURCE_SKIP（回合照样过）
		CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,0)
	CASE 4
		;等待原版COM执行。在原版COM的位置中用HAVE_CALLED-1==4来寻找它
	CASEELSE
		;其实就是CASE -1，只有它是要等原版的COM执行的
	ENDSELECT
ENDIF
CALLF DOKU_SL_COLOR("L")
RETURN LOCAL

@DOKU_COMF_CTRL_SYS(COMF_PRENAME,ARG:0=0,ARGS:0="",ARG:1=0,ARGS:1="",ARG:2=0,ARGS:2="",ARG:3=0,ARGS:3="")
;返回负数，匹配失败
;返回x，成功执行参数为x的情况
#DIMS COMF_PRENAME
VARSET RESULT
VARSET LOCAL

;DCCS已经应用成功，那么不执行（所以是放前面的优先）
SIF DOKUDIM_COMF_HAVE_CALLED(DOKUDIM_REAL_TARGET())
RETURN -1

CALL DOKU_COMF_CTRL_SYS_MODE_MATCH(ARG:0,ARGS:0,ARG:1,ARGS:1,ARG:2,ARGS:2,ARG:3,ARGS:3)
SELECTCASE RESULT + 1
CASE 0
	RETURN -1
CASE 1
	TRYCCALLFORM DCCS_SUCCESS_%COMF_PRENAME%_K{DOKUDIM_REAL_TARGET()}_{DOKUDIM_SELECTCOM()}
		IF RESULT < 0
		TRYCCALLFORM DCCS_FAIL_%COMF_PRENAME%_K{DOKUDIM_REAL_TARGET()}_{DOKUDIM_SELECTCOM()}(RESULT)
		CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,RESULT)
		RETURN 2
		CATCH
		RETURN 1
		ENDCATCH
		
		ELSE
		TRYCCALLFORM DCCS_CALC_%COMF_PRENAME%_K{DOKUDIM_REAL_TARGET()}_{DOKUDIM_SELECTCOM()}(RESULT)
		CATCH
		RETURN -1
		ENDCATCH
		
		CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,RESULT)
		TRYCCALLFORM DCCS_MESS_SOURCE_TRIGGER_%COMF_PRENAME%_K{DOKUDIM_REAL_TARGET()}_{DOKUDIM_SELECTCOM()}
		TRYCALLFORM DCCS_MESS_%COMF_PRENAME%_K{DOKUDIM_REAL_TARGET()}_{DOKUDIM_SELECTCOM()}(DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET()))
		CATCH

		CALLF DOKUDIMS_MESSAGE_USE_VANILLA_RESULT(DOKUDIM_REAL_TARGET(),1,@"{DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET())}")
		CALLF DOKUDIMS_MESSAGE_USE_VANILLA_COMF_PRENAME(DOKUDIM_REAL_TARGET(),1,COMF_PRENAME)
		ENDCATCH
		ENDIF
		
		IF DOKUDIM_REAL_TARGET()>0
		RETURN 0
		ELSE
		RETURN 3
		ENDIF
	CATCH
		RETURN -1
	ENDCATCH
CASE 2
	TRYCCALLFORM DCCS_FAIL_%COMF_PRENAME%_K{DOKUDIM_REAL_TARGET()}_{DOKUDIM_SELECTCOM()}
	CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,RESULT)
	RETURN 2
	CATCH
	RETURN 1
	ENDCATCH
	
CASE 3
	;偷懒的小trick
	;写FAKE是为了LOOKON要用，LOOKON指的是“旁观”，我就静静地看着你装b
	CALL FAKE_COM666666
	TRYCALLFORM DCCS_LOOKON_%COMF_PRENAME%_K{DOKUDIM_REAL_TARGET()}_{DOKUDIM_SELECTCOM()}(RESULT)
	RETURN 3
	
CASE 4
	TARGET = 0
	FINDELEMENT TARGET,DOKUDIM_REAL_TARGET(),1,CHARANUM
	LOCAL:1 = RESULT
	;本来就不在场，但SUCCESS只有在角色为TARGET时执行，所以这是是非法的情况
	IF LOCAL:1 == -1
	TARGET = DOKUDIM_REAL_TARGET()
	RETURN -666
	ENDIF
	LOCAL = FINDELEMENT(TARGET,0,1,CHARANUM)
	SIF LOCAL <= 1
	RETURN -666
	
	LOCAL --
	TARGET:(LOCAL:1) = TARGET:LOCAL
	TARGET:LOCAL = 0
	CALL FAKE_COM666666
	TRYCALLFORM DCCS_LOOKON_%COMF_PRENAME%_K{DOKUDIM_REAL_TARGET()}_{DOKUDIM_SELECTCOM()}(RESULT)
	
	TARGET:LOCAL = TARGET:(LOCAL:1)
	TARGET:(LOCAL:1) = DOKUDIM_REAL_TARGET()
	TARGET:0 = DOKUDIM_REAL_TARGET()
	
	RETURN 3
	
CASE 5
	;按原版处理（是为了做优先级）
	RETURN 4
	
CASEELSE

RETURN -666

ENDSELECT
RETURN -1

@DOKU_COMF_CTRL_SYS_MODE_MATCH(ARG:0=0,ARGS:0="",ARG:1=0,ARGS:1="",ARG:2=0,ARGS:2="",ARG:3=0,ARGS:3="")
;单纯的多次匹配
;没匹配到会返回-1
;返回值的设计是为了配合优先级做出拓展性，例如“某指令满足某个条件就不动，不满足这个却满足之后的某条件才进行操作”
LOCAL:0=-1
WHILE LOCAL:0<3 && (ARGS:(LOCAL:0 +1)!="")
LOCAL:0++
CALL DOKU_NUM_MATCH_SLASH_SPLIT(DOKUDIM_SELECTCOM(),ARGS:(LOCAL:0))
SIF RESULT
RETURN ARG:(LOCAL:0)
WEND
RETURN -1

@FAKE_COM666666
;它没有口上文本，文本放到DCCS里那个有COMF_PRENAME的MESSAGE里
TARGET = DOKUDIM_REAL_TARGET()


LOCAL = DOKUDIM_SELECTCOM() / 1000

IF LOCAL
TRYCCALLFORM SCOM{LOCAL}
CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,RESULT)
CATCH
ENDCATCH
ELSE
TRYCCALLFORM COM{DOKUDIM_SELECTCOM()}
CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,RESULT)
CATCH
ENDCATCH
ENDIF

;这里这么写只是方便统一给LOCAL赋RESULT的值而不用清零LOCAL
LOCAL = DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET())
RETURN LOCAL

@COM666666
;没有系统则自动填充回原版，就连MESSAGE函数也可以直接使用原版的那个函数。
;对于SCOM，MESSAGE函数的格式是：
;DCCS_KOJO_MESSAGE%口上名%_K{TARGET}_SCOM{LOCAL}
;例如我的SUCCESS如果是M_KOJO_66_SUCCESS_COM_KX_XXX
;那么我的口上名是_66
;那我这个函数就应该写成DCCS_KOJO_MESSAGE_66_SCOM_KX_XXX
;COM的话，把SCOM改成COM就好
;例如DCCS_KOJO_MESSAGE_66_COM_KX_XXX

VARSET LOCAL
VARSET RESULT
VARSET RESULTS
VARSET LOCALS

SELECTCASE DOKUDIM_COMF_HAVE_CALLED(DOKUDIM_REAL_TARGET()) - 1
CASE -1,4
	TARGET = DOKUDIM_REAL_TARGET()

	CALL DOKU_GET_KOJO_NAME(TARGET)
	LOCALS '= RESULTS
	LOCAL = DOKUDIM_SELECTCOM() / 1000
	IF LOCAL
	TRYCCALLFORM SCOM{LOCAL}
	CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,RESULT)
	
	CATCH
	THROW DCCS:不存在的SCOM
	;我不认为会触发这个
	ENDCATCH
	ELSE
	TRYCCALLFORM COM{DOKUDIM_SELECTCOM()}
	CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,RESULT)
	
	CATCH
	THROW DCCS:不存在的COM
	;我不认为会触发这个
	ENDCATCH
	ENDIF
CASEELSE
	;0替换1、2失败3执行过了，都不再次执行COM
ENDSELECT

LOCAL = DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET())

SIF DOKUDIM_PREVCOM() != DOKUDIM_SELECTCOM()
PREVCOM = 1000
;同一指令连续执行防御

IF LOCAL < 0
SELECTCOM = 999
;LOCAL<0的时候不进入MESS，所以有些操作必须在COM直接完成
CALLF DOKUDIM_COMF_HAVE_CALLED(DOKUDIM_REAL_TARGET(),1,0)
CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,0)
ENDIF

RETURN LOCAL


@USE_DCCS_P1(ARG)
SELECTCOM = 666666
RETURN 0





@USE_DCCS_P2(ARG)
;为了兼容原版的SOURCE，不得不增添一个时点
;在M_KOJO%口上名%_MESSAGE_COM_K{角色编号}_666666 中 调用
;启用了@USE_DCCS的话一定要启用@USE_DCCS_P2。

;多了这么个时点以后，发现一些操作顺畅了很多

TFLAG:50 = DOKUDIM_SELECTCOM() / 1000
IF TFLAG:50
TFLAG:3 = 999
SELECTCOM = 999
ELSE
TFLAG:3 = DOKUDIM_SELECTCOM()
SELECTCOM = TFLAG:3
ENDIF

IF ARG != DOKUDIM_REAL_TARGET()
;理论上不应该会触发
CALLF DOKUDIMS_MESSAGE_USE_VANILLA_RESULT(ARG,1,"")
CALLF DOKUDIMS_MESSAGE_USE_VANILLA_COMF_PRENAME(ARG,1,"")
RETURN 0
ENDIF

SELECTCASE DOKUDIM_COMF_HAVE_CALLED(ARG) - 1
CASE -1,4
	;跳过了、或者强制使用原版流程，都走原版的接口
	CALL DOKU_GET_KOJO_NAME(ARG)
	LOCALS '= RESULTS
	VARSET RESULT
	LOCAL = DOKUDIM_SELECTCOM() / 1000
	IF LOCAL
	LOCALS:1 '= @"SCOM_K{ARG}_{LOCAL}"
	ELSE
	LOCALS:1 = @"COM_K{ARG}_{DOKUDIM_SELECTCOM()}"
	ENDIF
	TRYCCALLFORM M_KOJO%LOCALS%_MESSAGE_%LOCALS:1%
	CATCH
	TRYCALLFORM M_KOJO%LOCALS%_MESSAGE_COM_K{ARG}_00
	ENDCATCH
CASE 0
	;正常且成功执行了替换的指令。
	;就算应当使用原版时点、使用的接口也应当带着COMPRE_NAME
	IF DOKUDIMS_MESSAGE_USE_VANILLA_RESULT(ARG) != ""
	TRYCALLFORM DCCS_MESS_%DOKUDIMS_MESSAGE_USE_VANILLA_COMF_PRENAME(ARG)%_K{ARG}_{DOKUDIM_SELECTCOM()}(TOINT(DOKUDIMS_MESSAGE_USE_VANILLA_RESULT(ARG)))
	CALLF DOKUDIMS_MESSAGE_USE_VANILLA_RESULT(ARG,1,"")
	CALLF DOKUDIMS_MESSAGE_USE_VANILLA_COMF_PRENAME(ARG,1,"")
	ENDIF
CASE 1,2,3
	;失败或者旁观、又或者SUCCESS==0的小旁观，都是不加好感的
	CALL DOKU_PHASE_MESSAGE_FIX_FAVOR_MOOD_BUG(ARG)
CASEELSE


ENDSELECT

CALLF DOKUDIM_COMF_HAVE_CALLED(TARGET,1,0)
CALLF DOKUDIM_COMF_RESULT(DOKUDIM_REAL_TARGET(),1,0)

RETURN 0

@DOKU_PHASE_MESSAGE_FIX_FAVOR_MOOD_BUG(ARG)
VARSET CUP:ARG
TFLAG:97 = -999999
TFLAG:98 = -999999
TFLAG:99 = -1
VARSET SOURCE:60
SOURCE:ARG:歓楽 = -1800
RETURN 0

