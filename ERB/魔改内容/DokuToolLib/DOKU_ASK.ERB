@DOKU_T_ASK_M(TIMINGMING,ARGS:0, ARG:0, ARGS:1, ARG:1, ARGS:2, ARG:2, ARGS:3, ARG:3, ARGS:4, ARG:4, ARGS:5, ARG:5, ARGS:6, ARG:6, ARGS:7, ARG:7, ARGS:8, ARG:8)
#DIM CONST MAX_OPTION_NUM = 8
#DIM DYNAMIC TIMINGMING
#DIM DYNAMIC CURRENT
#DIM DYNAMIC NOWCURRENT
#DIM DYNAMIC BIT_NOT_AVAI = 0
;当ARGS对应的ARG为1，是正常选项，为2，是不显示，为0，是显示但不可选
;TIMINGMING是倒计时，超时不选的话会返回选项数+1作为区分
CALLF DOKU_SL_COLOR("S")
FOR CURRENT, 0, (MAX_OPTION_NUM + 1)
IF ARGS:(CURRENT) != ""
IF ARG:(CURRENT) == 1
PRINTBUTTON @"[{CURRENT}]%ARGS:(CURRENT)%", CURRENT
PRINTL 
ELSEIF ARG:(CURRENT) == 2
SETBIT BIT_NOT_AVAI,CURRENT
PRINTL 
ELSE
SETCOLOR 0x606060
PRINTPLAINFORM [{CURRENT}]%ARGS:(CURRENT)%
SETBIT BIT_NOT_AVAI,CURRENT
RESETCOLOR
PRINTL 
ENDIF
NOWCURRENT = CURRENT
ENDIF
NEXT
TINPUT TIMINGMING,(NOWCURRENT+1),0,""
IF RESULT < 0 || (RESULT > NOWCURRENT) || ARGS:RESULT == "" || GETBIT(BIT_NOT_AVAI,RESULT)
CLEARLINE 1
CALLF DOKU_SL_COLOR("L")
RETURN NOWCURRENT+1
ELSE
CLEARLINE NOWCURRENT+2
PRINTPLAINFORM [{RESULT}]%ARGS:RESULT%
PRINTL
ENDIF
PRINTFORML {GETCOLOR()}
CALLF DOKU_SL_COLOR("L")
RETURN RESULT

@DOKU_OD_ASK_M(ARGS:0, ARG:0, ARGS:1, ARG:1, ARGS:2, ARG:2, ARGS:3, ARG:3, ARGS:4, ARG:4, ARGS:5, ARG:5, ARGS:6, ARG:6, ARGS:7, ARG:7, ARGS:8, ARG:8, ARGS:9, ARG:9, ARGS:10, ARG:10, ARGS:11, ARG:11, ARGS:12, ARG:12, ARGS:13, ARG:13, ARGS:14, ARG:14, ARGS:15, ARG:15, ARGS:16, ARG:16 ,ARGS:17,ARG:17,ARGS:18,ARG:18,ARGS:19,ARG:19,ARGS:20,ARG:20,ARGS:21,ARG:21,ARGS:22,ARG:22,ARGS:23,ARG:23,ARGS:24,ARG:24)
#DIM DYNAMIC CURRENT
#DIM DYNAMIC RRESULT
#DIM DYNAMIC NUM_OF_LINE_TO_CLEAR
#DIMS DYNAMIC MATCH_OPTION_STR
#DIM CONST MAX_OPTION_NUM_HERE = 25
;当ARGS对应的ARG为1，是正常选项，为2，是不显示且不可选，为0，是显示但不可选
;为3：1的情况，但是选项前面会多一个空行
;为4：0的情况，但是选项前面会多一个空行
;为5：2的情况，但显示的数字不算它。通过5-4*(条件)来让选项在5和1间切换
;为6：1的情况，但是高亮
;为666：可选，但【选前】没有按钮与文本（选后需要有所以ARGS还是不能为空）。以"字符串/*/数字"为格式能自定义选项对应的数字。彩蛋选项不能是最后一个选项
CALLF DOKU_SL_COLOR("S")
;颜色控制
NUM_OF_LINE_TO_CLEAR = 0
CURRENT = -1
MATCH_OPTION_STR '= ""
FOR LOCAL, 0, MAX_OPTION_NUM_HERE
IF ARGS:LOCAL != ""
	VARSET LOCALS
	SELECTCASE ARG:LOCAL
		CASE 0,1
		NUM_OF_LINE_TO_CLEAR ++
		CASE 3,4
		NUM_OF_LINE_TO_CLEAR += 2
	ENDSELECT
	CURRENT ++

	SELECTCASE ARG:LOCAL
	CASE 666
		;彩蛋选项
		VARSET LOCALS
		SPLIT ARGS:LOCAL,"/*/",LOCALS
		ISNUMERIC LOCALS:1
		SIF !RESULT
		GOTO OD_ASKM_CASE2
		ARGS:LOCAL '= LOCALS:0
		TOINT LOCALS:1
		IF RESULT >= MAX_OPTION_NUM_HERE
			ARG:(MAX_OPTION_NUM_HERE+LOCAL) = RESULT
			MATCH_OPTION_STR += @"%LOCALS:1%/"
		ELSE
			MATCH_OPTION_STR += @"{CURRENT}/"
		ENDIF
		CURRENT --
	CASE 5
		CURRENT --
	CASE 4
		PRINTL 
		SETCOLOR 0x606060
		PRINTPLAINFORM [{LOCAL}]%ARGS:(LOCAL)%
		RESETCOLOR
		PRINTL 
	CASE 3
		MATCH_OPTION_STR += @"{CURRENT}/"
		PRINTL 
		PRINTBUTTON @"[{CURRENT}]%ARGS:(LOCAL)%", CURRENT
		PRINTL 
	CASE 1,6
		IF ARG:LOCAL == 6
			SETCOLOR 0xFFFF00
			ARG:LOCAL = 1
		ENDIF
		MATCH_OPTION_STR += @"{CURRENT}/"
		PRINTBUTTON @"[{CURRENT}]%ARGS:(LOCAL)%", CURRENT
		PRINTL 
		RESETCOLOR
	CASE 0 
		SETCOLOR 0x606060
		PRINTPLAINFORM [{CURRENT}]%ARGS:(LOCAL)%
		RESETCOLOR
		PRINTL 
	CASE 2
		$OD_ASKM_CASE2
		;把这个case放到2上，是因为这样能用"2-是否可选"来得到正确的情况
		;如果应当显示，那么case1，如果不该显示，那么case2
	CASEELSE ;暂定：作为case1处理
		MATCH_OPTION_STR += @"{CURRENT}/"
		PRINTBUTTON @"[{CURRENT}]%ARGS:(LOCAL)%", CURRENT
		PRINTL      
ENDSELECT
SELECTCASE ARG:LOCAL
CASE 0,1,3,4
ARG:CURRENT = LOCAL
CASEELSE
ENDSELECT
;CURRENT一定小于LOCAL，在这个位置已经不需要ARG:CURRENT里的控制变量了，所以可以用ARG:CURRENT去存CURRENT对应的真实LOCAL
LOCAL:1 = LOCAL
ENDIF
NEXT
$INPUT_LOOP
INPUT
RRESULT = RESULT
IF RRESULT < 0 ;单独限制
CLEARLINE 1
GOTO INPUT_LOOP
ENDIF
IF !DOKU_NUM_MATCH_SLASH_SPLIT_F(RRESULT,MATCH_OPTION_STR)
CLEARLINE 1
GOTO INPUT_LOOP
ELSE
IF RRESULT >= MAX_OPTION_NUM_HERE
FOR LOCAL,0,LOCAL:1
LOCAL:2 = LOCAL
IF ARG:(MAX_OPTION_NUM_HERE+LOCAL) == RRESULT
LOCAL:2 = -1*MAX_OPTION_NUM_HERE - LOCAL:2
BREAK
ENDIF
NEXT
IF LOCAL:2<0
LOCAL:2 *= -1
LOCAL:2 -= MAX_OPTION_NUM_HERE
CLEARLINE NUM_OF_LINE_TO_CLEAR +1
PRINTPLAINFORM [{RRESULT}]%ARGS:(LOCAL:2)%
PRINTL
RRESULT = LOCAL:2
;获取真实RESULT
ELSE
CLEARLINE 1
GOTO INPUT_LOOP
ENDIF
ELSE
CLEARLINE NUM_OF_LINE_TO_CLEAR +1
PRINTPLAINFORM [{RRESULT}]%ARGS:(ARG:RRESULT)%
PRINTL
RRESULT = ARG:RRESULT
;获取真实RESULT
ENDIF
ENDIF
CALLF DOKU_SL_COLOR("L")
RETURN RRESULT

@DOKU_FLICKER_ASK_M(TIMINGMING1,TIMINGMING2,ARGS:0, ARG:0 = 0, ARGS:1, ARG:1 = 0, ARGS:2, ARG:2 = 0, ARGS:3, ARG:3 = 0, ARGS:4, ARG:4 = 0, ARGS:5, ARG:5 = 0, ARGS:6, ARG:6 = 0, ARGS:7, ARG:7 = 0, ARGS:8, ARG:8 = 0)
#DIM DYNAMIC TIMINGMING1
#DIM DYNAMIC TIMINGMING2
#DIM DYNAMIC CURRENT
#DIM DYNAMIC NOWCURRENTHERE
#DIM CONST MAX_OPTION_NUM = 8
;闪烁之ask，ARGS对应的ARG为1是显示，为0是闪烁
CALLF DOKU_SL_COLOR("S")
FOR CURRENT, 0, (MAX_OPTION_NUM + 1)
SIF ARGS:(CURRENT) != ""
NOWCURRENTHERE = CURRENT
NEXT
$MARK_FLICKER_ASK_M
CALL DOKU_T_ASK_M(TIMINGMING1,ARGS:0, ARG:0 > 0, ARGS:1, ARG:1 > 0, ARGS:2, ARG:2 > 0, ARGS:3, ARG:3 > 0, ARGS:4, ARG:4 > 0, ARGS:5, ARG:5 > 0, ARGS:6, ARG:6 > 0, ARGS:7, ARG:7 > 0, ARGS:8, ARG:8 > 0)
IF RESULT == NOWCURRENTHERE + 1
CLEARLINE NOWCURRENTHERE+1
CALL DOKU_T_ASK_M(TIMINGMING2,ARGS:0, ARG:0, ARGS:1, ARG:1, ARGS:2, ARG:2, ARGS:3, ARG:3, ARGS:4, ARG:4, ARGS:5, ARG:5, ARGS:6, ARG:6, ARGS:7, ARG:7, ARGS:8, ARG:8)
IF RESULT == NOWCURRENTHERE + 1
CLEARLINE NOWCURRENTHERE+1
GOTO MARK_FLICKER_ASK_M
ELSE
CALLF DOKU_SL_COLOR("L")
RETURN RESULT
ENDIF
ELSE
CALLF DOKU_SL_COLOR("L")
RETURN RESULT
ENDIF
CALLF DOKU_SL_COLOR("L")
RETURN RESULT

@DOKU_QTE_ASK_M(TIMINGMING,ARGS:0, ARG:0, ARGS:1, ARG:1, ARGS:2, ARG:2, ARGS:3, ARG:3, ARGS:4, ARG:4, ARGS:5, ARG:5, ARGS:6, ARG:6, ARGS:7, ARG:7, ARGS:8, ARG:8)
#DIM CONST MAX_OPTION_NUM = 8
#DIM DYNAMIC TIMINGMING,3
#DIM DYNAMIC CURRENT
#DIM DYNAMIC NOWCURRENT
#DIM DYNAMIC BIT_NOT_AVAI = 0
;当ARGS对应的ARG为1，是正常选项，为2，是不显示，为0，是显示但不可选
;TIMINGMING是倒计时，超时不选的话会返回选项数+1作为区分
CALLF DOKU_SL_COLOR("S")
FOR CURRENT, 0, (MAX_OPTION_NUM + 1)
IF ARGS:(CURRENT) != ""
IF ARG:(CURRENT) == 1
PRINTBUTTON @"[{CURRENT}]%ARGS:(CURRENT)%", CURRENT
PRINTL 
ELSEIF ARG:(CURRENT) == 2
SETBIT BIT_NOT_AVAI,CURRENT
PRINTL 
ELSE
SETCOLOR 0x606060
PRINTPLAINFORM [{CURRENT}]%ARGS:(CURRENT)%
SETBIT BIT_NOT_AVAI,CURRENT
RESETCOLOR
PRINTL 
ENDIF
NOWCURRENT = CURRENT
ENDIF
NEXT
GETMILLISECOND
TIMINGMING:1 = RESULT:0
$INPUTAGAIN
GETMILLISECOND
TIMINGMING:2 = TIMINGMING:0 - (RESULT:0-TIMINGMING:1)
;trick，直接获取系统时间而不是计算
PRINTFORML {TIMINGMING:2/1000}.{(TIMINGMING:2 +1000)%1000}
TINPUT 20,(NOWCURRENT+1),0,""
CLEARLINE 2
IF RESULT < 0 || (RESULT > NOWCURRENT) || ARGS:RESULT == "" || GETBIT(BIT_NOT_AVAI,RESULT)
SIF TIMINGMING:2 >0
GOTO INPUTAGAIN
CLEARLINE NOWCURRENT+1
CALLF DOKU_SL_COLOR("L")
RETURN NOWCURRENT+1,0
ELSE
CLEARLINE NOWCURRENT+2
PRINTPLAINFORM [{RESULT}]%ARGS:RESULT%
PRINTL
ENDIF
CALLF DOKU_SL_COLOR("L")
RETURN RESULT,TIMINGMING:2

@DOKU_QTE_I_ASK_M(TIMINGMING:0,DISPLAY_CD_MODE=0,ARGS:0="", ARG:0=1, ARGS:1="", ARG:1=1, ARGS:2="", ARG:2=1, ARGS:3="", ARG:3=1, ARGS:4="", ARG:4=1, ARGS:5="", ARG:5=1, ARGS:6="", ARG:6=1, ARGS:7="", ARG:7=1, ARGS:8="", ARG:8=1)
#DIM DYNAMIC TIMINGMING,3
#DIM DISPLAY_CD_MODE
#DIM DYNAMIC BIT_AVAI=0
#DIM DYNAMIC END_OF_CHOICE = -1
#DIM DYNAMIC NUM_OF_CHOICE = 0
;当ARGS对应的ARG为1，是正常选项，为2，是不显示，为0，是显示但不可选
;为不小于10的正数，是“经过x毫秒后切替”，为小于0的负数，是“经过多少毫秒后消失”，会有十几毫秒的误差
;如果切替，则“选择切替前的选项，返回【-1*选项编号-1】”,否则正常返回选项编号。切替选项的格式是"切替前/切替后"
;TIMINGMING是倒计时，单位毫秒，根据电脑性能可能有十几毫秒的误差，超时不选的话会返回选项数+1作为区分
;DISPLAY_CD_MODE为0是不显示倒计时，1是在开始显示，2是在末尾显示
;I指Integrate，集成
CALLF DOKU_SL_COLOR("S")
GETMILLISECOND
TIMINGMING:1 = RESULT:0
LOCAL:0 = -1
;预处理
WHILE 1
LOCAL:0 ++
IF ARGS:(LOCAL:0)!=""
END_OF_CHOICE = LOCAL:0
IF (ARG:(LOCAL:0) == 1 || ARG:(LOCAL:0)>=10 || ARG:(LOCAL:0)<0)
SETBIT BIT_AVAI,LOCAL:0
NUM_OF_CHOICE ++
ENDIF
SIF ARG:(LOCAL:0)==0
NUM_OF_CHOICE ++
ENDIF
SIF LOCAL:0 >8
BREAK
WEND
SIF END_OF_CHOICE == -1
THROW 一个选项都没有，seriously？
WHILE 1
GETMILLISECOND
TIMINGMING:2 = RESULT:0 - TIMINGMING:1 ;经过的时间
SIF TIMINGMING:2 >= TIMINGMING:0
BREAK
TIMINGMING:2 = TIMINGMING:0 - TIMINGMING:2 ;倒计时
SIF DISPLAY_CD_MODE==1
PRINTFORML {TIMINGMING:2/1000}.{(TIMINGMING:2 +1000)%1000}
LOCAL:0 = -1
WHILE 1
LOCAL:0 ++
IF ARG:(LOCAL:0) == 2 || ARGS:(LOCAL:0)==""
CLEARBIT BIT_AVAI,LOCAL:0
ELSEIF ARG:(LOCAL:0)<0 && (ARG:(LOCAL:0)+TIMINGMING:2>=0)
ARG:(LOCAL:0)=2
CLEARBIT BIT_AVAI,LOCAL:0
NUM_OF_CHOICE -- ;消失不留空行，和FLICKER不同
ELSEIF ARG:(LOCAL:0)<0 || ARG:(LOCAL:0)==1
PRINTBUTTON @"[{LOCAL:0}]%ARGS:(LOCAL:0)%", LOCAL:0
PRINTL 
ELSEIF ARG:(LOCAL:0) == 0
SETCOLOR 0x606060
PRINTPLAINFORM [{LOCAL:0}]%ARGS:(LOCAL:0)%
RESETCOLOR
PRINTL 
ELSEIF ARG:(LOCAL:0)>=10
SPLIT ARGS:(LOCAL:0),"/",LOCALS
IF TIMINGMING:2<=ARG:(LOCAL:0)
IF LOCALS:0 !="" ;空字符串的话显示空行且选不了
SETBIT BIT_AVAI,LOCAL:0
PRINTBUTTON @"[{LOCAL:0}]%LOCALS:0%", LOCAL:0
ELSE
CLEARBIT BIT_AVAI,LOCAL:0
ENDIF
PRINTL 
ELSE
IF LOCALS:1 !=""
SETBIT BIT_AVAI,LOCAL:0
PRINTBUTTON @"[{LOCAL:0}]%LOCALS:1%", LOCAL:0
ELSE
CLEARBIT BIT_AVAI,LOCAL:0
ENDIF
PRINTL 
ENDIF
ENDIF
SIF LOCAL:0 > END_OF_CHOICE
BREAK
WEND
SIF DISPLAY_CD_MODE==2
PRINTFORML {TIMINGMING:2/1000}.{(TIMINGMING:2 +1000)%1000}
TINPUT 20,(END_OF_CHOICE+1),0,""
LOCAL:2 = RESULT:0
IF LOCAL:2<0 || !GETBIT(BIT_AVAI,MIN(0,LOCAL:2)) || LOCAL:2 > END_OF_CHOICE
CLEARLINE NUM_OF_CHOICE + 1+(DISPLAY_CD_MODE && 1) ;加的是“如果显示了倒计时，把倒计时刷新”
CONTINUE
ELSE
CLEARLINE NUM_OF_CHOICE + 1+(DISPLAY_CD_MODE && 1)
SPLIT ARGS:(LOCAL:2),"/",LOCALS
IF ARG:(LOCAL:2)>=10 && TIMINGMING:2<=ARG:(LOCAL:2)
PRINTPLAINFORM [{LOCAL:2}]%LOCALS:0%
PRINTL 
CALLF DOKU_SL_COLOR("L")
RETURN -1*LOCAL:2 -1
ELSEIF ARG:(LOCAL:2)>=10
PRINTPLAINFORM [{LOCAL:2}]%LOCALS:1%
PRINTL 
CALLF DOKU_SL_COLOR("L")
RETURN LOCAL:2
ELSE
PRINTPLAINFORM [{LOCAL:2}]%ARGS:(LOCAL:2)%
PRINTL 
CALLF DOKU_SL_COLOR("L")
RETURN LOCAL:2
ENDIF
ENDIF
WEND
CALLF DOKU_SL_COLOR("L")
RETURN END_OF_CHOICE+1