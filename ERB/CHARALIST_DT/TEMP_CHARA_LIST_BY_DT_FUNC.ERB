;リストの背景色を設定する関数。ここで背景描写を行うわけではない
@LIST_CHANGE_COLOR()
#DIM CNT
#DIM L_IS_BRANK
#DIM L_VALID_BUTTON
#DIM L_NOWCOLOR
#DIM L_G = 0
#DIM L_COLOR
#DIM L_ARRAYNUM
#DIM L_LC , 2
#DIMS L_STR
#DIMS L_RS
#DIM CONST C_G_START = 1
#DIM CONST C_G_END = POWER(2 , 32) - 1
#DIM CONST C_SPR_W = 10
#DIMS CONST C_CHANGE_COLOR = "CHANGE_COLOR_"
#DIMS CONST C_CHANGE_ALPHA = "CHANGE_ALPHA_"
#DIMS CONST C_DELETE_LIST_COLOR = "DELETE_COLOR_"
#DIMS CONST C_SET_DEFAULT = "SET_DEFAULT"
#DIMS CONST C_END_CHANGE = "CHANGE_END"
#DIMS CONST C_SPR = "LIST_BY_DT_CHANGE_COLOR_SPRITE"
#DIMS CONST C_SAMPLE_CHAR = "あ" , "い" , "う" , "え" , "お" , "か" , "き" , "く" , "け" , "こ"
;足したい色あったら足してね！
{
#DIMS CONST C_PRESET_COLOR = 
	"ORANGE" , 
	"ROYALBLUE" , 
	"GOLD" , 
	"DEEPPINK" , 
	"PALEGREEN" , 
	"KHAKI" , 
	"BLACK" , 
	"WHITE" , 
	"LIGHTBLUE" , 
	"LIME" , 
	"SADDLEBROWN" , 
	"VIOLET" , 
	"SALMON"
}

DRAWLINE


[SKIPSTART]
IF L_G == 0
	;この関数が占有するGを検索
	FOR CNT , C_G_START , C_G_END
		IF GCREATED(CNT) == 0
			L_G = CNT
			BREAK
		ENDIF
	NEXT
	GOTO REDRAW_G
ELSE
	$REDRAW_G
	IF GCREATED(L_G) == 0
		GCREATE L_G , GETCONFIG("フォントサイズ") * (C_SPR_W + 4) , GETCONFIG("一行の高さ") * VARSIZE("LIST_COLOR")
	ELSE
		GCLEAR L_G , 0x0
	ENDIF
ENDIF

;見本L_Gにストライプ状に着色する
L_NOWCOLOR = 0
FOR CNT , 0 , VARSIZE("LIST_COLOR")
	GSETBRUSH L_G , LIST_COLOR:L_NOWCOLOR
	GFILLRECTANGLE L_G , 0 , CNT * GETCONFIG("一行の高さ") , GWIDTH(L_G) , GETCONFIG("一行の高さ")
	;次の色が見つからなかったらLIST_COLOR配列の先頭に戻す
	L_NOWCOLOR = (L_NOWCOLOR + 1) % VARSIZE("LIST_COLOR")
	SIF LIST_COLOR:L_NOWCOLOR / 0x1000000 == 0
		L_NOWCOLOR = 0
NEXT
[SKIPEND]


;L_Gに重ねる文字見本、およびスペース確保用の改行記号を連打
$REDRAW_G
L_STR = 
L_ARRAYNUM = 0
FOR CNT , 0 , VARSIZE("LIST_COLOR")
	IF STRLENS(L_STR) == 0
		L_COLOR = BLEND_ARGB_RGB(LIST_COLOR:L_ARRAYNUM , GETBGCOLOR())
		{
		HTML_PRINT @"[%C_SAMPLE_CHAR:(CNT % VARSIZE("C_SAMPLE_CHAR")) * C_SPR_W%　　　　]" + @"
		<div height='{GETCONFIG("一行の高さ") + 1}px' 
		width='{(C_SPR_W+4) * 100}' xpos='-{(C_SPR_W + 5) * 100}' ypos='0' color='#%INT_TO_RGB(L_COLOR)%'
		depth='1'
		></div>"
		}
		SIF LIST_COLOR:(++L_ARRAYNUM) / 0x1000000 == 0
			L_ARRAYNUM = 0
		;L_STR '= "[" + C_SAMPLE_CHAR:(CNT % VARSIZE("C_SAMPLE_CHAR")) * C_SPR_W + "]"
	ELSE
		;L_STR += "<br>" + "[" + C_SAMPLE_CHAR:(CNT % VARSIZE("C_SAMPLE_CHAR")) * C_SPR_W + "]"
	ENDIF
NEXT

[SKIPSTART]
;スプライトを作って見本表示
SPRITEDISPOSE C_SPR
SPRITECREATE C_SPR , L_G
PRINTL ＜みほん＞
HTML_PRINT @"<img src='%C_SPR%' width='{GWIDTH(L_G)}px' height='{GHEIGHT(L_G)}px' ypos='0px'><div height='{VARSIZE("LIST_COLOR") * GETCONFIG("一行の高さ") + 1}px' width='{(C_SPR_W+4) * 100}' xpos='-{GWIDTH(L_G)}px' ypos='0' color='#'></div>"
;<div height='{VARSIZE("LIST_COLOR") * GETCONFIG("一行の高さ") + 1}px' width='{(C_SPR_W+4) * 100}' xpos='-{GWIDTH(L_G)}px' ypos='0'>%L_STR%</div>"
HTML_PRINT @"%"<br>"*9%"
[SKIPEND]

DRAWLINE

;色の選択肢を表示
L_VALID_BUTTON = 0
L_IS_BRANK = 0
FOR CNT , 0 , VARSIZE("LIST_COLOR")
	;如果alpha为0则为未设置
	IF LIST_COLOR:CNT / 0x1000000 % 0x100 == 0
		;太麻烦了就直接删除
		LIST_COLOR:CNT = 0x0

		;如果数组中有空白，则只显示一个，如果连续出现两个空白，则停止尝试
		IF L_IS_BRANK
			BREAK
		ELSE
			PRINTFORM %TOFULL(TOSTR(CNT + 1)) , 4%号　
			PRINTBUTTON "[无背景色    ]" , @"%C_CHANGE_COLOR%{CNT}"
			PRINT 　
			PRINTBUTTON "[无透明度 ]" , @"%C_CHANGE_ALPHA%{CNT}"
			PRINTL 

			L_IS_BRANK++
			L_VALID_BUTTON++
			PRINTL 
			CONTINUE
		ENDIF
	ENDIF
	PRINTFORM %TOFULL(TOSTR(CNT + 1)) , 4%号　
	PRINTBUTTON @"[背景色0x%INT_TO_RGB(LIST_COLOR:CNT)%]" , @"%C_CHANGE_COLOR%{CNT}"
	PRINT 　
	PRINTBUTTON @"[透明度0x{LIST_COLOR:CNT / 0x1000000 % 0x100 , 3 , LEFT}]" , @"%C_CHANGE_ALPHA%{CNT}"
	PRINT 　
	PRINTBUTTON @"[删除此颜色]" , @"%C_DELETE_LIST_COLOR%{CNT}"
	PRINTL 
	L_VALID_BUTTON++
NEXT

DRAWLINE
PRINTBUTTON @"[设置结束]" , C_END_CHANGE
PRINT 　　　　
PRINTBUTTON @"[恢复列表默认颜色]" , C_SET_DEFAULT
PRINTL 
DRAWLINE
PRINTFORML 您想设置列表背景色的哪种颜色？

L_LC = LINECOUNT
$INPUT_LOOP
CLEARLINE LINECOUNT - L_LC

INPUTS
L_RS '= RESULTS

IF STRCOUNT(L_RS , C_CHANGE_COLOR)
	;设置RGB值
	L_RS '= REPLACE(L_RS , C_CHANGE_COLOR , "")
	SIF ISNUMERIC(L_RS) == 0 || INRANGE(TOINT(L_RS) , 0 , L_VALID_BUTTON) == 0
		GOTO INPUT_LOOP

	L_ARRAYNUM = TOINT(L_RS)

	PRINTFORML 请点击要设置为第{L_ARRAYNUM + 1}号背景色的颜色，或输入颜色名称，或输入颜色的RGB值（RRGGBB格式）
	L_STR = 
	FOR CNT , 0 , VARSIZE("C_PRESET_COLOR")
		L_STR += @"<font color='%C_PRESET_COLOR:CNT%'><button value='%C_PRESET_COLOR:CNT%'>■</button></font>"
	NEXT
	HTML_PRINT L_STR

	PRINTBUTTON "[取消]" , "-999"

	L_LC:1 = LINECOUNT
	$INPUT_LOOP2
	CLEARLINE LINECOUNT - L_LC:1

	CALL INPUTS_NO_BRANK
	L_RS '= RESULTS

	;将输入转换为颜色数值
	IF L_RS == "-999"
		GOTO REDRAW_G
	ELSEIF COLOR_FROMNAME(L_RS) >= 0
		L_COLOR = COLOR_FROMNAME(L_RS)
	;向ISNUMERIC传递"0xdeeppink"这样的字符串会报错并崩溃（是否误解为2*X的Y次方表示XpY？）
	;因此，带有颜色名deep○○的会崩溃，请注意（"0xAAPCV"不会崩溃并返回0，"0xAAPVV"会崩溃。似乎取决于p后面的字符？）
	;如果满足以下3个条件，即：1、单词开头或结尾以外包含p；2、p之前的所有字符都是abcdef或数字；3、p紧跟的不是abcdef或数字，那么在字符串前加上"0x"并进行ISNUMERIC操作时会崩溃？
	ELSEIF STRFINDU(TOLOWER(L_RS) , "deep") > 0 && ISNUMERIC(@"0x%L_RS%") && INRANGE(TOINT(@"0x%L_RS%") , 0 , 0xFFFFFF)
		L_COLOR = TOINT(@"0x%L_RS%")
	ELSE
		GOTO INPUT_LOOP2
	ENDIF

	LIST_COLOR:L_ARRAYNUM = LIST_COLOR:L_ARRAYNUM / 0x1000000 % 0x100 * 0x1000000 + L_COLOR
	;如果设置后的alpha为0，则稍微设置一下alpha
	SIF LIST_COLOR:L_ARRAYNUM / 0x1000000 % 0x100 == 0
		LIST_COLOR:L_ARRAYNUM += 0x10000000
	PRINTFORMW 已将列表背景色第{L_ARRAYNUM + 1}号设置为RGB值%INT_TO_RGB(L_COLOR)%
	GOTO REDRAW_G
ELSEIF STRCOUNT(L_RS , C_CHANGE_ALPHA)
	;设置alpha值
	L_RS '= REPLACE(L_RS , C_CHANGE_ALPHA , "")
	SIF ISNUMERIC(L_RS) == 0 || INRANGE(TOINT(L_RS) , 0 , L_VALID_BUTTON) == 0
		GOTO INPUT_LOOP

	L_ARRAYNUM = TOINT(L_RS)

	;透明度0完全不着色，等同于未设置
	PRINTFORML 请输入要设置为第{L_ARRAYNUM + 1}号背景色的透明度，范围为1～255。输入范围外的值将中止
	PRINTFORML 指定0将清除颜色（因为透明度0不会绘制任何东西）

	INPUT
	;虽然不是颜色设置的地方，但还是用了L_COLOR
	L_COLOR = RESULT

	SIF INRANGE(L_COLOR , 0 , 0xFF) == 0
		GOTO REDRAW_G

	LIST_COLOR:L_ARRAYNUM = LIST_COLOR:L_ARRAYNUM % 0x1000000 + L_COLOR * 0x1000000
	IF L_COLOR == 0
		PRINTFORMW 指定的透明度值为0。因此已删除列表背景色第{L_ARRAYNUM + 1}号
	ELSE
		PRINTFORMW 已将列表背景色第{L_ARRAYNUM + 1}号设置为透明度值{L_COLOR}
	ENDIF
	GOTO REDRAW_G
ELSEIF STRCOUNT(L_RS , C_DELETE_LIST_COLOR)
	;删除指定的背景色
	L_RS '= REPLACE(L_RS , C_DELETE_LIST_COLOR , "")
	SIF INRANGE(TOINT(L_RS) , 0 , L_VALID_BUTTON) == 0
		GOTO INPUT_LOOP

	PRINTFORML 确定要删除第{TOINT(L_RS)+1}号背景色的颜色吗？
	PRINTFORML 颜色：%TOSTR(LIST_COLOR:TOINT(L_RS) % 0x1000000 , "X2")%　　透明度：%TOSTR(LIST_COLOR:TOINT(L_RS) / 0x1000000 , "X2")%

	CALL ASK_YN

	IF RESULT == 0
		ARRAYSHIFT LIST_COLOR , -1 , 0x0 , TOINT(L_RS)
		PRINTFORMW 已删除第{TOINT(L_RS)+1}号背景色的颜色
		GOTO REDRAW_G
	ELSE
		GOTO INPUT_LOOP
	ENDIF
ELSEIF STRCOUNT(L_RS , C_SET_DEFAULT)
	PRINTFORML 确定要初始化列表的颜色设置吗？
	CALL ASK_YN

	IF RESULT == 0
		CALL LIST_COLOR_SET_DEFAULT
		PRINTFORMW 已初始化列表颜色
	ENDIF
	GOTO REDRAW_G
ELSEIF STRCOUNT(L_RS , C_END_CHANGE)
	;结束设置更改
	;下次函数执行时会复用相同的SPRITE和G，所以不用销毁
	;GDISPOSE L_G
	;SPRITEDISPOSE C_SPR
	RETURN 1
ENDIF
GOTO INPUT_LOOP


;LIST_COLOR配列をLIST_COLOR_DEFAULT配列で初期化する
@LIST_COLOR_SET_DEFAULT
#DIM CNT
VARSET LIST_COLOR
ARRAYCOPY "LIST_COLOR_DEFAULT" , "LIST_COLOR"
RETURN 1


;現在のカラムグループから移動可能かどうかを判定する関数
@MOVE_COLUMN_GROUP(ARG_NOW_GROUP = 0 , ARG_MOVE = 1)
#FUNCTION
#DIM ARG_NOW_GROUP
#DIM ARG_MOVE
#DIM L_ARRAYNUM
#DIM L_COUNTER
#DIM L_SIGN

SIF ARG_MOVE == 0
	RETURNF ARG_NOW_GROUP

L_ARRAYNUM = ARG_NOW_GROUP
L_SIGN = ARG_MOVE >= 0 ? 1 # -1
L_COUNTER = 0
DO
	L_ARRAYNUM += L_SIGN
	L_ARRAYNUM = VALUE_LOOP(L_ARRAYNUM , 0 , MAX_COLUMN_GROUP - 1)

	IF STRLENS(COLUMN_GROUP_NAME:L_ARRAYNUM)
		L_COUNTER += L_SIGN
		SIF L_COUNTER == ARG_MOVE
			RETURNF L_ARRAYNUM
	ENDIF
LOOP 1
;ここには来ない
RETURNF -1


;<---じゃあくなかんすう--->
@GET_INT_BY_NAME_ELEM(ARG_CHR = -1 , ARG_VARNAME = "" , ARG_VARELEM = -1)
#FUNCTION
#DIMS ARG_VARNAME
#DIM ARG_VARELEM
#DIM ARG_CHR
#DIM L_TEMP

SELECTCASE ARG_VARNAME
	CASE "ABL"
		L_TEMP = ABL:ARG_CHR:ARG_VARELEM
	CASE "TALENT"
		L_TEMP = TALENT:ARG_CHR:ARG_VARELEM
	CASE "CFLAG"
		L_TEMP = CFLAG:ARG_CHR:ARG_VARELEM
	CASE "BASE"
		L_TEMP = BASE:ARG_CHR:ARG_VARELEM
	CASE "MAXBASE"
		L_TEMP = MAXBASE:ARG_CHR:ARG_VARELEM
	CASE "MARK"
		L_TEMP = MARK:ARG_CHR:ARG_VARELEM
	CASE "TCVAR"
		L_TEMP = TCVAR:ARG_CHR:ARG_VARELEM
	CASEELSE
		THROW ARG_VARNAME未定义为变量名 ARG_VARNAME=%ARG_VARNAME%
ENDSELECT

RETURNF L_TEMP
;<------------------------>


;<---じゃあくなかんすう--->
@GET_NAME_BY_NAME_ELEM(ARG_VARNAME = "" , ARG_VARELEM = -1)
#FUNCTIONS
#DIMS ARG_VARNAME
#DIMS L_TEMP
#DIM ARG_VARELEM

SELECTCASE ARG_VARNAME
	CASE "ABL"
		L_TEMP '= NAME_TR(ABLNAME:ARG_VARELEM)
	CASE "TALENT"
		L_TEMP '= NAME_TR(TALENTNAME:ARG_VARELEM)
	CASE "CFLAG"
		L_TEMP '= NAME_TR(CFLAGNAME:ARG_VARELEM)
	CASE "BASE"
		L_TEMP '= NAME_TR(BASENAME:ARG_VARELEM)
	CASE "MAXBASE"
		L_TEMP '= NAME_TR(BASENAME:ARG_VARELEM)
	CASE "MARK"
		L_TEMP '= NAME_TR(MARKNAME:ARG_VARELEM)
	CASE "TCVAR"
		L_TEMP '= NAME_TR(TCVARNAME:ARG_VARELEM)
	CASEELSE
		THROW ARG_VARNAME未定义为变量名 ARG_VARNAME=%ARG_VARNAME%
ENDSELECT

RETURNF L_TEMP
;<------------------------>


[SKIPSTART]
ゲージを表示する
ARG_GAUGE      :表示するゲージの現在値
ARG_MAXGAUGE   :表示するゲージの最大値
ARG_LEN        ;表示するゲージの長さ。半角文字数何個分かで示す
ARG_GAUGECOLOR :ゲージに着色する色。0xRRGGBB形式
ARG_BACKCOLOR  :ゲージの背景色。0xRRGGBB形式
ARG_PRINT_VALUE:数値としてARG_GAUGE、ARG_MAXGAUGEを出力するかフラグ。1以上ならその数値を最大桁数として出力、0以下ならしない。既定0
[SKIPEND]
@FREEBAR(ARG_GAUGE = 0 , ARG_MAXGAUGE = 100 , ARG_LEN = 10 , ARG_GAUGECOLOR = 0xFFFFFF , ARG_BACKCOLOR = 0x222222 , ARG_PRINT_VALUE = 0)
#DIM ARG_GAUGE
#DIM ARG_MAXGAUGE
#DIM ARG_LEN ;指定は半角文字数
#DIM ARG_GAUGECOLOR
#DIM ARG_BACKCOLOR
#DIM L_GAUGE_BACKLEN
#DIM L_GAUGE_LEN
#DIM L_MOD
#DIM ARG_PRINT_VALUE
#DIMS L_HTML
#DIMS L_STRVALUE

SIF ARG_MAXGAUGE <= 0
	THROW 最大槽长必须大于等于1 ARG_MAXGAUGE={ARG_MAXGAUGE}
ARG_GAUGE = LIMIT(ARG_GAUGE , 0 , ARG_MAXGAUGE)

IF ARG_PRINT_VALUE > 0
	L_STRVALUE '= @" ({ARG_GAUGE , ARG_PRINT_VALUE , RIGHT}/{ARG_MAXGAUGE , ARG_PRINT_VALUE , RIGHT})"
	ARG_LEN -= STRLENS(L_STRVALUE)
ELSE
	VARSET L_STRVALUE
ENDIF

L_GAUGE_LEN = ARG_GAUGE * 100 / ARG_MAXGAUGE
L_GAUGE_BACKLEN = (ARG_MAXGAUGE - ARG_GAUGE) * 100 / ARG_MAXGAUGE

;余り処理
WHILE L_GAUGE_LEN + L_GAUGE_BACKLEN < 100
	IF ARG_GAUGE * 10000 / ARG_MAXGAUGE % 10000 >= 5000
		L_GAUGE_LEN += 1
	ELSE
		L_GAUGE_BACKLEN += 1
	ENDIF
WEND

L_GAUGE_LEN = ARG_LEN / 2 * L_GAUGE_LEN
L_GAUGE_BACKLEN = ARG_LEN / 2 * L_GAUGE_BACKLEN

L_HTML = 
IF L_GAUGE_LEN > 0
	;L_HTML += @"<shape type='rect' param='0 , 10 , {L_GAUGE_LEN} , 70' color='#%INT_TO_RGB(ARG_GAUGECOLOR)%'>"
	SETCOLOR ARG_GAUGECOLOR
	;wikiにpx表記できるって書いてあるけどどうやるんだ…？
	PRINT_RECT 0 , 15 , L_GAUGE_LEN , 70
ENDIF
IF L_GAUGE_BACKLEN > 0
	;L_HTML += @"<shape type='rect' param='0 , 10 , {L_GAUGE_BACKLEN} , 70' color='#%INT_TO_RGB(ARG_BACKCOLOR)%'>"
	SETCOLOR ARG_BACKCOLOR
	PRINT_RECT 0 , 15 , L_GAUGE_BACKLEN , 70
ENDIF

HTML_PRINT L_HTML
RESETCOLOR

SIF STRLENS(L_STRVALUE)
	PRINTS L_STRVALUE
;SIF STRLENS(L_STRVALUE)
;	L_HTML += L_STRVALUE

RETURN 1
;RETURNF L_HTML


;INT型の数値をRRGGBB形式の文字列にして返す
@INT_TO_RGB(ARG_INT = 0)
#FUNCTIONS
#DIM ARG_INT

RETURNF TOSTR(ARG_INT / 0x10000 % 0x100 , "X2") + TOSTR(ARG_INT / 0x100 % 0x100 , "X2") + TOSTR(ARG_INT % 0x100 , "X2")


;INT型の数値をAARRGGBB形式の文字列にして返す
@INT_TO_ARGB(ARG_INT = 0)
#FUNCTIONS
#DIM ARG_INT

RETURNF TOSTR(ARG_INT / 0x1000000 % 0x100 , "X2") + TOSTR(ARG_INT / 0x10000 % 0x100 , "X2") + TOSTR(ARG_INT / 0x100 % 0x100 , "X2") + TOSTR(ARG_INT % 0x100 , "X2")


;溜まってる度表示時の@FREEBARで使う色定義
;結果はRESULT:0とRESULT:1に入れ、この式中間数自体は与えられた数の割合(ARG_SEIYOKU * 100 / ARG_SEIYOKU_MAX)を返す
@SEIYOKU_COLOR(ARG_SEIYOKU = 0 , ARG_SEIYOKU_MAX = 1000)
#FUNCTION
#DIM ARG_SEIYOKU
#DIM ARG_SEIYOKU_MAX
#DIM L_PROPOTION
#DIM CONST CON_THRESHOLD = 30 , 60
#DIM L_COLOR , 3
#DIM L_COLOR_BACK , 3

SIF ARG_SEIYOKU_MAX <= 0
	THROW 最大欲求不满度不可为0　ARG_SEIYOKU_MAX={ARG_SEIYOKU_MAX}

L_PROPOTION = ARG_SEIYOKU * 100 / ARG_SEIYOKU_MAX

L_COLOR:0 = COLOR_FROMNAME("ROYALBLUE")
L_COLOR_BACK:0 = COLOR_FROMNAME("MIDNIGHTBLUE")

L_COLOR:1 = COLOR_FROMNAME("GOLD")
L_COLOR_BACK:1 = 0x2D2600

L_COLOR:2 = COLOR_FROMNAME("HOTPINK")
L_COLOR_BACK:2 = 0x650065

SELECTCASE L_PROPOTION
	CASE IS <= CON_THRESHOLD:0
		RESULT:1 = L_COLOR_BACK:0
		RETURNF L_COLOR:0
	CASE IS <= CON_THRESHOLD:1
		RESULT:1 = L_COLOR_BACK:1
		RETURNF L_COLOR:1
	CASEELSE
		RESULT:1 = L_COLOR_BACK:2
		RETURNF L_COLOR:2
ENDSELECT


;値をループさせる式中関数
@VALUE_LOOP(ARG_VALUE , ARG_VMIN , ARG_VMAX)
#FUNCTION
#DIM ARG_VALUE
#DIM ARG_VMIN
#DIM ARG_VMAX
#DIM L_RANGE

L_RANGE = ARG_VMAX - ARG_VMIN + 1
SIF L_RANGE <= 0
	THROW ARG_VMAXとARG_VMINが不正  ARG_VMAX={ARG_VMAX}  ARG_VMIN={ARG_VMIN}

RETURNF ARG_VMIN + ((ARG_VALUE - ARG_VMIN) % L_RANGE + L_RANGE) % L_RANGE


;フィルターで使う評価演算子を単語に直して返す
;ARG_FOR_BUTTONに1が代入されたときはボタンで使うとき
@FILTER_OPR_TO_STR(ARG_OPR = "" , ARG_FOR_BUTTON = 0)
#FUNCTIONS
#DIM ARG_FOR_BUTTON
#DIMS ARG_OPR

SELECTCASE ARG_OPR
	CASE "<"
		RETURNF "小于"
	CASE ">"
		RETURNF "大于"
	CASE "="
		IF ARG_FOR_BUTTON
			RETURNF "等于"
		ELSE
			RETURNF "与其等价"
		ENDIF
	CASE "<="
		RETURNF "小于等于"
	CASE ">="
		RETURNF "大于等于"
	CASEELSE
		THROW 评价运算符"%ARG_OPR%"未定义
ENDSELECT


;昇順/降順を三角、逆三角に直して返す
@SORT_TYPE_TO_TRIANGLE(ARG_TYPE = "")
#FUNCTIONS
#DIMS ARG_TYPE
SELECTCASE ARG_TYPE
	CASE "ASC"
		RETURNF "▲"
	CASE "DESC"
		RETURNF "▼"
	CASEELSE
		RETURNF ""
ENDSELECT


;ASC/DESCを単語にして返す
@SORT_TYPE_TO_NAME(ARG_TYPE = "")
#FUNCTIONS
#DIMS ARG_TYPE
SELECTCASE ARG_TYPE
	CASE "ASC"
		RETURNF "升序"
	CASE "DESC"
		RETURNF "降序"
	CASEELSE
		RETURNF "无"
ENDSELECT


;LISTにカラムを足す処理
;溜まってる度や生理周期が見られない状態でも推測できてしまうので一律禁止に
@LIST_BY_DT_ADD_ANY_COLUMN(ARG_COLUMN_GROUP)
#DIM ARG_COLUMN_GROUP
#DIM L_ELEM
#DIM CNT
#DIMS L_RS
#DIMS L_ARRAYNAME
#DIMS L_SELECTLIST , 10
#DIMS L_ANSWERLIST , 10

;[IF_NDEBUG]
RETURN 0
;[ENDIF]

;空いている配列添え字を検索
L_ELEM = -1
;FINDELEMENTは空文字列を探せない(配列の内容が何であろうと最初の要素がヒットするらしい)
FOR CNT , VARSIZE("COLUMN_NAME" , 1) - 1 , -1 , -1
	IF (CNT == 0 || COLUMN_NAME:ARG_COLUMN_GROUP:(CNT - 1) != "") && STRLENS(COLUMN_NAME:ARG_COLUMN_GROUP:CNT) == 0
		L_ELEM = CNT
		BREAK
	ENDIF
NEXT
IF L_ELEM == -1
	PRINTFORMW 没有空余的列。添加结束。
	RETURN 0
ENDIF

;首先选择变量名
PRINTL 要添加哪个类别？
VARSET L_SELECTLIST
VARSET L_ANSWERLIST
L_SELECTLIST:0 '= "[素质]" , "[能力]" , "[FLAG]"
L_ANSWERLIST:0 '= "TALENT" , "ABL" , "CFLAG"
CALL ASK_M_REF(L_SELECTLIST , L_ANSWERLIST)

SIF RESULTS == ""
	RETURN 0

L_ARRAYNAME '= RESULTS

;选择变量的元素名
PRINTFORML 请通过素质的名称或编号指定要设置为列的素质
$ADDCOL_LOOP1
CALL INPUTS_NO_BRANK
L_RS '= RESULTS

IF ISNUMERIC(L_RS)
	IF INRANGE(TOINT(L_RS) , 0 , VARSIZE(L_ARRAYNAME) - 1) == 0
		PRINTFORMW %L_RS%超出了素质的范围
		CLEARLINE 2
		GOTO ADDCOL_LOOP1
	ELSEIF GET_NAME_BY_NAME_ELEM(L_ARRAYNAME , TOINT(L_RS)) == ""
		;如果TALENTNAME为空字符串，则视为未设置
		PRINTFORMW %L_RS%似乎没有作为素质使用
		CLEARLINE 2
		GOTO ADDCOL_LOOP1
	ENDIF
ELSE
	RESULTS = %L_ARRAYNAME%NAME
	L_RS = {FINDELEMENT(RESULTS , L_RS , , , 1)}
	IF L_RS == "-1"
		PRINTFORMW %L_RS%没有作为素质名称使用
		CLEARLINE 2
		GOTO ADDCOL_LOOP1
	ENDIF
ENDIF

COLUMN_VAR:ARG_COLUMN_GROUP:L_ELEM = %L_ARRAYNAME%,%L_RS%
PRINTFORML 已将素质名：%GET_NAME_BY_NAME_ELEM(L_ARRAYNAME , TOINT(L_RS))%设置为参照对象
PRINTFORML 
PRINTFORML 请设置此列的名称

$ADDCOL_LOOP2
CALL INPUTS_NO_BRANK
L_RS '= RESULTS

PRINTFORML 列的名称是"%L_RS%"，确定吗？
CALL ASK_YN

IF RESULT == 1
	CLEARLINE 5
	GOTO ADDCOL_LOOP2
ENDIF

PRINTFORML 请决定此列的显示形式
VARSET L_SELECTLIST
VARSET L_ANSWERLIST
;进度条形式暂时保留
;"[1]进度条形式（体力、气力等）"
;"BAR"
L_SELECTLIST '= "[2]等级·数值形式（能力等）" , "[3]真伪·枚举型（素质等）"
L_ANSWERLIST = "2" , "3"

;不能放弃选择
CALL ASK_M_REF(L_SELECTLIST , L_ANSWERLIST , "")

IF ISNUMERIC(RESULTS) == 0
	PRINTFORMW 意外的分支 RESULTS=%RESULTS%
	RESTART
ENDIF

COLUMN_TYPE:ARG_COLUMN_GROUP:L_ELEM = TOINT(RESULTS)
PRINTFORMW 已添加列%COLUMN_NAME:ARG_COLUMN_GROUP:L_ELEM%
RETURN 1


;DT作成で使うカラム設定配列を初期化する
;該当する配列すべてを消去する。-1だと全てのカラムに対して実行
@LIST_BY_DT_COLUMN_INIT(ARG_COLUMN_GROUP = -1)
#DIM CNT_0
#DIM CNT_1
#DIM ARG_COLUMN_GROUP
#DIM L_ARRAYNUM

[SKIPSTART]
COLUMN_GROUP_NAME:CNT_0 '= 
COLUMN_VAR:CNT_0:0      '= 
COLUMN_NAME:CNT_0:0     '= 
COLUMN_LEN:CNT_0:0       = 
COLUMN_TYPE:CNT_0:0      = 
[SKIPEND]

VARSET COLUMN_GROUP_NAME
VARSET COLUMN_GROUP_PRESET
VARSET COLUMN_NAME:0:0
VARSET COLUMN_VAR:0:0
VARSET COLUMN_TYPE:0:0
VARSET COLUMN_IS_FIX:0:0
;COLUMN_LENは0以上にセットするとそのカラムの幅は設定済みと解釈されてCOLUMN_NAMEを使った計測をしなくなる
VARSET COLUMN_LEN:0:0 , -1

;まずカラムグループのカラム設定プリセットを読み込む
FOR CNT_0 , INRANGE(ARG_COLUMN_GROUP, 0, VARSIZE("COLUMN_GROUP_NAME") - 1) ? ARG_COLUMN_GROUP # 0, INRANGE(ARG_COLUMN_GROUP, 0, VARSIZE("COLUMN_GROUP_NAME") - 1) ? (ARG_COLUMN_GROUP + 1) # VARSIZE("COLUMN_GROUP_NAME")
	;カラムグループ1～4は固定、5以降は自由にしてみる
	SELECTCASE CNT_0
		CASE 0
			COLUMN_GROUP_NAME:CNT_0 '= "体力气力"
			COLUMN_GROUP_NAME_FIX:CNT_0 = 1
			COLUMN_GROUP_PRESET:CNT_0:0 '= "体力" , "气力" , "积攒度" , "关系性" , "处女" , "キス未経験"
			COLUMN_IS_FIX:CNT_0:0 = 1, 1, 1, 1, 1, 1
			;COLUMN_VARは添え字の後ろに,STRと付けると列が文字列で用意される
			;COLUMN_NAMEは左側にソートの昇順or降順orソート無しを示すため半角２文字が足される
			[SKIPSTART]
			COLUMN_VAR:CNT_0:0      '= "BASE,0" , "MAXBASE,0" , "BASE,1" , "MAXBASE,1" , "CFLAG,340" , "TALENT,0"
			COLUMN_NAME:CNT_0:0     '= "体力" , "最大体力" , "气力" , "最大气力" , "欲求" , "处女"
			COLUMN_LEN:CNT_0:0       = 22 , 22 , 22 , 22 , 8 , 4
			;COLUMN_TYPE=1は２個１組で処理される
			COLUMN_TYPE:CNT_0:0      = 1 , 1 , 1 , 1 , 2 , 7
			[SKIPEND]
		CASE 1
			COLUMN_GROUP_NAME:CNT_0 '= "性素质"
			COLUMN_GROUP_NAME_FIX:CNT_0 = 1
			COLUMN_GROUP_PRESET:CNT_0:0 '= "Ｃ感觉" , "Ｖ感觉" , "Ａ感觉" , "Ｂ感觉", "Ｍ感觉" , "亲密" , "顺从" , "欲望" , "技巧" , "侍奉精神" , "露出癖"
			COLUMN_IS_FIX:CNT_0:0 = 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
			[SKIPSTART]
			COLUMN_VAR:CNT_0:0      '= "ABL,0" , "ABL,1" , "ABL,2" , "ABL,3" , "ABL,4" , "ABL,9" , "ABL,10" , "ABL,11" , "ABL,12" , "ABL,13" , "ABL,14"
			COLUMN_NAME:CNT_0:0     '= "Ｃ感觉", "Ｖ感觉", "Ａ感觉", "Ｂ感觉", "Ｍ感觉" , "亲密", "顺从", "欲望", "技巧" , "侍奉" , "露出"
			;COLUMN_LEN:CNT_0:0       = 
			COLUMN_TYPE:CNT_0:0      = 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4
			[SKIPEND]
		CASE 2
			COLUMN_GROUP_NAME:CNT_0 '= "性技巧"
			COLUMN_GROUP_NAME_FIX:CNT_0 = 1
			COLUMN_GROUP_PRESET:CNT_0:0 '= "指" , "舌" , "胸" , "腰" , "膣" , "Ａ"
			COLUMN_IS_FIX:CNT_0:0 = 1, 1, 1, 1, 1, 1
			[SKIPSTART]
			COLUMN_VAR:CNT_0:0      '= "ABL,50" , "ABL,51" , "ABL,52" , "ABL,53" , "ABL,54" , "ABL,55"
			COLUMN_NAME:CNT_0:0     '= "指技", "舌技", "胸技", "腰技", "膣技", "Ａ技"
			;COLUMN_LEN:CNT_0:0       = 
			COLUMN_TYPE:CNT_0:0      = 4 , 4 , 4 , 4 , 4 , 4
			[SKIPEND]
		CASE 3
			;苦痛とか时奸はネガティブなのかポジティブなのか判断つかんかった
			COLUMN_GROUP_NAME:CNT_0 '= "刻印"
			COLUMN_GROUP_NAME_FIX:CNT_0 = 1
			COLUMN_GROUP_PRESET:CNT_0:0 '= "苦痛刻印" , "快乐刻印" , "顺从刻印" , "反感刻印" , "时奸刻印"
			COLUMN_IS_FIX:CNT_0:0 = 1, 1, 1, 1, 1
			[SKIPSTART]
			COLUMN_VAR:CNT_0:0      '= "MARK,0" , "MARK,1" , "MARK,2" , "MARK,3" , "MARK,5"
			COLUMN_NAME:CNT_0:0     '= "苦痛", "快乐", "顺从", "反感", "时奸"
			COLUMN_LEN:CNT_0:0       = 4 , 4 , 4 , 4 , 4
			COLUMN_TYPE:CNT_0:0      = 10 , 8 , 8 , 9 , 10
			[SKIPEND]
		CASE 4
			COLUMN_GROUP_NAME:CNT_0 '= "好感度"
			COLUMN_GROUP_NAME_FIX:CNT_0 = 1
			COLUMN_GROUP_PRESET:CNT_0:0 '= "好感度" , "信赖度" , "积攒度"
			COLUMN_IS_FIX:CNT_0:0 = 1, 1, 1
			[SKIPSTART]
			COLUMN_VAR:CNT_0:0      '= "CFLAG,2" , "CFLAG,4" , "CFLAG,340"
			COLUMN_NAME:CNT_0:0     '= "好感", "信頼", "性欲"
			COLUMN_LEN:CNT_0:0       = 6 , 6 , 10
			COLUMN_TYPE:CNT_0:0      = 6 , 5 , 2
			[SKIPEND]
		CASE 5
			COLUMN_GROUP_NAME:CNT_0 '= "性经历·素质"
			COLUMN_GROUP_PRESET:CNT_0:0 '= "处女" , "キス未経験" , "Ｃ感度" , "Ｖ感度" , "Ａ感度" , "Ｂ感度" , "Ｍ感度"
			[SKIPSTART]
			COLUMN_VAR:CNT_0:0      '= "TALENT,0" , "TALENT,6" , "TALENT,101" , "TALENT,102" , "TALENT,103" , "TALENT,104" , "TALENT,106" , "TALENT,105" , "TALENT,108"
			COLUMN_NAME:CNT_0:0     '= "处女", "キス", "Ｃ感", "Ｖ感", "Ａ感", "Ｂ感" , "Ｍ感" , "乳SIZE" , "尻SIZE"
			COLUMN_LEN:CNT_0:0       = 12 , 12 , 4 , 4 , 4 , 4 , 4 , 6 , 6
			COLUMN_TYPE:CNT_0:0      = 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11
			[SKIPEND]
		CASEELSE
			;例外
	ENDSELECT

	;設定されたプリセットを元にデータ読み込み
	L_ARRAYNUM = 0 ;データ格納"先"の配列添え字記録用。TYPE=1があるので必ずしもCNT_1と一致しない
	FOR CNT_1 , 0 , VARSIZE("COLUMN_GROUP_PRESET" , 1)
		SIF STRLENS(COLUMN_GROUP_PRESET:CNT_0:CNT_1) == 0
			BREAK

		;カラムの型を設定
		CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_TYPE)
		COLUMN_TYPE:CNT_0:L_ARRAYNUM = RESULT

		IF COLUMN_TYPE:CNT_0:L_ARRAYNUM == 1
			;TYPE=1は２個１組
			COLUMN_TYPE:CNT_0:(L_ARRAYNUM + 1) = COLUMN_TYPE:CNT_0:L_ARRAYNUM

			;名前を設定
			CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_NAME)
			COLUMN_NAME:CNT_0:L_ARRAYNUM '= RESULTS:0
			COLUMN_NAME:CNT_0:(L_ARRAYNUM + 1) '= RESULTS:1

			;参照変数を設定
			CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_VAR)
			COLUMN_VAR:CNT_0:L_ARRAYNUM '= RESULTS:0
			COLUMN_VAR:CNT_0:(L_ARRAYNUM + 1) '= RESULTS:1

			;カラムの長さを設定
			CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_LEN)
			COLUMN_LEN:CNT_0:L_ARRAYNUM = RESULT
			COLUMN_LEN:CNT_0:(L_ARRAYNUM + 1) = RESULT

			L_ARRAYNUM += 2
		ELSEIF COLUMN_TYPE:CNT_0:L_ARRAYNUM == 14
			;TYPE=14は２個１組
			COLUMN_TYPE:CNT_0:(L_ARRAYNUM + 1) = COLUMN_TYPE:CNT_0:L_ARRAYNUM

			;名前を設定
			CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_NAME)
			COLUMN_NAME:CNT_0:L_ARRAYNUM '= RESULTS:0
			COLUMN_NAME:CNT_0:(L_ARRAYNUM + 1) '= DEF_SORT_FOR_14 + RESULTS:0

			;参照変数を設定
			CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_VAR)
			COLUMN_VAR:CNT_0:L_ARRAYNUM '= RESULTS:0
			COLUMN_VAR:CNT_0:(L_ARRAYNUM + 1) '= RESULTS:1

			;カラムの長さを設定
			CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_LEN)
			COLUMN_LEN:CNT_0:L_ARRAYNUM = RESULT
			COLUMN_LEN:CNT_0:(L_ARRAYNUM + 1) = RESULT

			L_ARRAYNUM += 2
		ELSE
			;名前を設定
			CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_NAME)
			COLUMN_NAME:CNT_0:L_ARRAYNUM '= RESULTS:0

			;参照変数を設定
			CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_VAR)
			COLUMN_VAR:CNT_0:L_ARRAYNUM '= RESULTS:0

			;カラムの長さを設定
			CALLFORM DEFINE_COLUMN_%COLUMN_GROUP_PRESET:CNT_0:CNT_1%(DEF_COLUMN_LEN)
			COLUMN_LEN:CNT_0:L_ARRAYNUM = RESULT

			L_ARRAYNUM += 1
		ENDIF
	NEXT

	;もし未設定ならカラムの幅計算
	FOR CNT_1 , 0 , VARSIZE("COLUMN_NAME" , 1)
		SIF STRLENS(COLUMN_NAME:CNT_0:CNT_1) == 0
			CONTINUE
		;最後の+2はソート状態表示用に必要
		IF COLUMN_LEN:CNT_0:CNT_1 > -1
			COLUMN_LEN:CNT_0:CNT_1 += 2
		ELSE
			COLUMN_LEN:CNT_0:CNT_1 = STRLENS(COLUMN_NAME:CNT_0:CNT_1) + STRLENS(COLUMN_NAME:CNT_0:CNT_1) % 2 + 2
		ENDIF
	NEXT
NEXT

RETURN ARG_COLUMN_GROUP


;変数から必要があると思われる変数をXMLに記録する。XML変数を初期化する
;他に記録しておくべき物ある？
@LIST_BY_DT_SAVEXML()
#DIM CNT_0
#DIM CNT_1

LIST_BY_DT_XML = <ROOT />

;共通データ
XML_ADDNODE LIST_BY_DT_XML , @"/ROOT" , @"<%XML_PER_PAGE%>{PER_PAGE}</%XML_PER_PAGE%>"

;カラム系データ
FOR CNT_0 , 0 , MAX_COLUMN_GROUP
	SIF STRLENS(COLUMN_GROUP_NAME:CNT_0) == 0
		CONTINUE

	XML_ADDNODE LIST_BY_DT_XML , @"/ROOT" , @"<%XML_COLUMN_GROUP% %XML_ATTR_CG_NAME_FIX%='{COLUMN_GROUP_NAME_FIX:CNT_0}'>%COLUMN_GROUP_NAME:CNT_0%</%XML_COLUMN_GROUP%>"

	FOR CNT_1 , 0 , MAX_COLUMN
		SIF STRLENS(COLUMN_NAME:CNT_0:CNT_1) == 0
			BREAK
		XML_ADDNODE LIST_BY_DT_XML , @"/ROOT/%XML_COLUMN_GROUP%[last()]" , @"<%XML_COLUMN_NAME%>%COLUMN_NAME:CNT_0:CNT_1%</%XML_COLUMN_NAME%>" , 0 , 1
		XML_ADDATTRIBUTE LIST_BY_DT_XML , @"/ROOT/%XML_COLUMN_GROUP%[last()]/%XML_COLUMN_NAME%[last()]" , XML_ATTR_VAR , COLUMN_VAR:CNT_0:CNT_1 , 0 , 1
		XML_ADDATTRIBUTE LIST_BY_DT_XML , @"/ROOT/%XML_COLUMN_GROUP%[last()]/%XML_COLUMN_NAME%[last()]" , XML_ATTR_LEN , TOSTR(COLUMN_LEN:CNT_0:CNT_1) , 0 , 1
		XML_ADDATTRIBUTE LIST_BY_DT_XML , @"/ROOT/%XML_COLUMN_GROUP%[last()]/%XML_COLUMN_NAME%[last()]" , XML_ATTR_TYPE , TOSTR(COLUMN_TYPE:CNT_0:CNT_1) , 0 , 1
		XML_ADDATTRIBUTE LIST_BY_DT_XML , @"/ROOT/%XML_COLUMN_GROUP%[last()]/%XML_COLUMN_NAME%[last()]" , XML_ATTR_FIX , TOSTR(COLUMN_IS_FIX:CNT_0:CNT_1) , 0 , 1
	NEXT
NEXT

;ソートとフィルターは保存しなくていいんじゃないかな？
;ソートデータ
[SKIPSTART]
FOR CNT_0 , 0 , LIST_MAX_SORT
	XML_ADDNODE LIST_BY_DT_XML , @"/ROOT" , @"<%XML_SORT_TARGET% @%XML_SORT_IS_ASC%='{SORT_IS_ASC:CNT_0}'>%SORT_TARGET:CNT_0%</%XML_SORT_TARGET%>"
NEXT

;フィルターデータ
FOR CNT_0 , 0 , LIST_MAX_FILTER
	SIF STRLENS(FILTER_TARGET:CNT_0) == 0
		CONTINUE
	XML_ADDNODE LIST_BY_DT_XML , @"/ROOT" , @"<%XML_FILTER_TARGET%>%FILTER_TARGET:CNT_0%</%XML_FILTER_TARGET%>"
	XML_ADDNODE LIST_BY_DT_XML , @"/ROOT" , @"<%XML_FILTER_OPR%>%FILTER_OPR:CNT_0%</%XML_FILTER_OPR%>"
	XML_ADDNODE LIST_BY_DT_XML , @"/ROOT" , @"<%XML_FILTER_NUMBER%>%FILTER_NUMBER:CNT_0%</%XML_FILTER_NUMBER%>"
NEXT
[SKIPEND]

;リストの着色設定
FOR CNT_0 , 0 , VARSIZE("LIST_COLOR")
	;アルファが非0の物のみ有効な設定値とみなす
	SIF INRANGE(LIST_COLOR:CNT_0 / 0x1000000 % 0x100 , 0x1 , 0xFF)
		XML_ADDNODE LIST_BY_DT_XML , @"/ROOT" , @"<%XML_LIST_COLOR%>{LIST_COLOR:CNT_0}</%XML_LIST_COLOR%>"
NEXT
RETURN 1


@ASK_M_REF(ARG_NAME , ARG_ANSWER , ARG_CAN_CANCEL = "選択を中止する")
#DIMS REF ARG_NAME
#DIMS REF ARG_ANSWER
#DIMS L_RS
#DIM CNT
#DIMS ARG_CAN_CANCEL
#DIMS CONST ASK_M_REF_CANCEL = "ASK_M_REF_CANCEL"

SIF VARSIZE("ARG_NAME") != VARSIZE("ARG_ANSWER") || VARSIZE("ARG_NAME") <= 1
	THROW 传入数组的元素数量不正确  ARG_NAME={VARSIZE("ARG_NAME")}  ARG_ANSWER={VARSIZE("ARG_ANSWER")}

FOR CNT , 0 , VARSIZE("ARG_NAME")
	SIF STRLENS(ARG_NAME:CNT) == 0
		CONTINUE
	IF STRLENS(ARG_ANSWER:CNT) == 0
		SETCOLORBYNAME GRAY
		PRINTPLAINFORM %ARG_NAME:CNT%
		RESETCOLOR
	ELSE
		PRINTBUTTON ARG_NAME:CNT , ARG_ANSWER:CNT
		PRINTL 
	ENDIF
NEXT

IF ARG_CAN_CANCEL != ""
	PRINTL 
	PRINTBUTTON @"[%ARG_CAN_CANCEL%]" , ASK_M_REF_CANCEL
	PRINTL
ENDIF

$ASK_M_REF_LOOP1
INPUTS
L_RS '= RESULTS

IF L_RS == ASK_M_REF_CANCEL && ARG_CAN_CANCEL != ""
	RESULTS = 
	RETURN -1
ENDIF

IF FINDELEMENT(ARG_ANSWER , L_RS , , , 1) >= 0
	RESULTS '= L_RS
	RETURN FINDELEMENT(ARG_ANSWER , L_RS , , , 1)
ENDIF

GOTO ASK_M_REF_LOOP1


;渡されたARG_FILTER_TARGET、ARG_FILTER_OPR、ARG_FILTER_NUMBER配列から、DT_SELECTで使うフィルター文字列を生成
@BUILD_FILTER(ARG_FILTER_TARGET , ARG_FILTER_OPR , ARG_FILTER_NUMBER , ARG_SORT_TARGET , ARG_DTNAME = "")
#FUNCTIONS
#DIMS REF ARG_FILTER_TARGET
#DIMS REF ARG_FILTER_OPR
#DIMS REF ARG_FILTER_NUMBER
#DIMS REF ARG_SORT_TARGET
#DIMS ARG_DTNAME
#DIMS L_FILTER_TEMP
#DIM CNT

VARSET L_FILTER_TEMP

FOR CNT , 0 , VARSIZE("ARG_FILTER_TARGET")
	SELECTCASE (STRLENS(ARG_FILTER_TARGET:CNT) == 0) + (STRLENS(ARG_FILTER_OPR:CNT) == 0) + (STRLENS(ARG_FILTER_NUMBER:CNT) == 0)
		CASE 3
			;フィルターが存在しないなら次へ
			CONTINUE
		CASE 0
			;フィルター成立なら下へ流す
		CASE 1 , 2
			;(ないはずだけど)もしフィルターが中途半端にできていたら後ろの配列を前にずらして消す
			ARRAYSHIFT ARG_FILTER_TARGET , -1 , "" , CNT
			ARRAYSHIFT ARG_FILTER_OPR , -1 , "" , CNT
			ARRAYSHIFT ARG_FILTER_NUMBER , -1 , "" , CNT
			CONTINUE
	ENDSELECT

	IF STRLENS(L_FILTER_TEMP) == 0
		L_FILTER_TEMP = %ARG_FILTER_TARGET:CNT% %ARG_FILTER_OPR:CNT% %ARG_FILTER_NUMBER:CNT%
	ELSE
		;文字列andかorで接続すれば複数条件いけるらしい
		L_FILTER_TEMP = %L_FILTER_TEMP% and %ARG_FILTER_TARGET:CNT% %ARG_FILTER_OPR:CNT% %ARG_FILTER_NUMBER:CNT%
	ENDIF
NEXT

;ソート対象を参照し、ソート対象のセルが無効数値である行を除外するフィルターを足す
FOR CNT , 0 , VARSIZE("ARG_SORT_TARGET")
	SIF STRLENS(ARG_SORT_TARGET:CNT) == 0
		BREAK
	IF STRLENS(L_FILTER_TEMP) == 0
		IF DT_COLUMN_EXIST(ARG_DTNAME , ARG_SORT_TARGET:CNT) == 5
			L_FILTER_TEMP = %ARG_SORT_TARGET:CNT%<>'%STR_DISABLE%'
		ELSE
			L_FILTER_TEMP = %ARG_SORT_TARGET:CNT%<>{INT_DISABLE}
		ENDIF
		;L_FILTER_TEMP = %ARG_SORT_TARGET:CNT%<>{INT_DISABLE}
	ELSE
		IF DT_COLUMN_EXIST(ARG_DTNAME , ARG_SORT_TARGET:CNT) == 5
			L_FILTER_TEMP = %L_FILTER_TEMP% and %ARG_SORT_TARGET:CNT%<>'%STR_DISABLE%'
		ELSE
			L_FILTER_TEMP = %L_FILTER_TEMP% and %ARG_SORT_TARGET:CNT%<>{INT_DISABLE}
		ENDIF
	ENDIF
NEXT

RETURNF L_FILTER_TEMP


;渡されたARG_SORT_TARGET、ARG_IS_ASC配列から、DT_SELECTで使うソート文字列を生成
@BUILD_SORTRULE(ARG_SORT_TARGET , ARG_SORT_IS_ASC)
#FUNCTIONS
#DIMS REF ARG_SORT_TARGET
#DIM REF ARG_SORT_IS_ASC
#DIMS L_SORT_RULE_TEMP
#DIM CNT

VARSET L_SORT_RULE_TEMP

FOR CNT , 0 , LIST_MAX_SORT
	IF STRLENS(ARG_SORT_TARGET:CNT) > 0
		;L_SORT_IS_ASCとL_SORT_RULE_TARGETが両方空文字ならL_SORT_RULE_TEMPをDT_SELECTへ渡しても問題ないかと思ったが、
		;半角スペースが渡され、それで列が検索される(当然見つからない)のでエラー落ちしてしまう。よって分岐
		IF STRLENS(L_SORT_RULE_TEMP) == 0
			L_SORT_RULE_TEMP = %ARG_SORT_TARGET:CNT% %DT_SORT_TYPE:(ARG_SORT_IS_ASC:CNT)%
		ELSE
			L_SORT_RULE_TEMP = %L_SORT_RULE_TEMP%,%ARG_SORT_TARGET:CNT% %DT_SORT_TYPE:(ARG_SORT_IS_ASC:CNT)%
		ENDIF
	ENDIF
NEXT
RETURNF L_SORT_RULE_TEMP


;INPUTSにおいて空文字列の入力を拒否する。それだけ
@INPUTS_NO_BRANK()
RESULTS = 
DO
	INPUTS
	SIF STRLENS(RESULTS) > 0
		BREAK
LOOP 1
RETURN 1


;ARG_COLGのカラムグループにプリセットからカラムを追加する
;関数名がPRINT_ってなっているけど、ここでカラムの選択と追加もやってしまう
;2025/9/22  さらに拡張され、列グループを編集する関数になりました
;変更した数をL_RESULTに入れて返す
@PRINT_PRESET_COLUMN(ARG_COLG = 0)
#DIM ARG_COLG ;選択中のカラムグループ
#DIMS L_PRESET_PRINTNAME , 20 ;プリセットの集団の名前
#DIMS L_PRESET_FUNCNAME , 20 , 20 ;プリセットを呼ぶための関数の名前(@DEFINE_COLUMN_XXXのXXXに当たる)
#DIMS L_PRESET_NAME , 20 , 20 ;プリセットを選択肢として表示する際に使われる名前。空欄ならFUNCNAMEが使われる
#DIMS L_RS
#DIMS L_TEMPS
#DIM L_RESULT
#DIM L_ARRAYNUM
#DIM L_LC , 3
#DIM CNT_0
#DIM CNT_1
#DIM CNT_2
#DIM L_TARGETCOL , 2
#DIMS CONST C_BUTTON_PRESET = "SELECT_PRESET_"
#DIMS CONST C_BUTTON_REMOVE_COLUMN = "REMOVE_COLUMN_"
#DIMS CONST C_BUTTON_REMOVE_CGROUP = "REMOVE_CGROUP"
#DIMS CONST C_BUTTON_CHANGE_CGROUP_NAME = "CHANGE_COLUMN_GROUP_NAME"
#DIMS CONST C_BUTTON_END = "SELECT_END"

VARSET L_RESULT

L_LC:0 = LINECOUNT
$PRINT_COLUMN_LIST
CLEARLINE LINECOUNT - L_LC:0

;为了避免与之前的显示混淆，进行换行
PRINTL 
PRINTL 
PRINTL 
DRAWLINE
PRINTFORML 正在编辑表单「%COLUMN_GROUP_NAME:ARG_COLG%」…
DRAWLINE

VARSET L_PRESET_PRINTNAME
VARSET L_PRESET_FUNCNAME
VARSET L_PRESET_NAME

;显示已设置的列和数组的空余
VARSET L_TEMPS
FOR CNT_0 , 0 , MAX_COLUMN
	IF STRLENS(COLUMN_NAME:ARG_COLG:CNT_0)
		IF COLUMN_IS_FIX:ARG_COLG:CNT_0
			;如果设置了固定Flag，则不可删除
			L_RS = <nonbutton title='此列已固定。无法删除'><font color='gray'>[%COLUMN_NAME:ARG_COLG:CNT_0%]</font></nonbutton>
		ELSE
			L_RS = <button value='%C_BUTTON_REMOVE_COLUMN%{CNT_0}'>[%COLUMN_NAME:ARG_COLG:CNT_0%]</button>
		ENDIF
	ELSE
		L_RS = <font color='gray'>[------]</font>
	ENDIF

	L_TEMPS += @"\@ STRLENS(L_TEMPS) ? 　　%L_RS% # %L_RS% \@"
NEXT

PRINTFORML 点击以下白色列名即可删除：
HTML_PRINT L_TEMPS

DRAWLINE

HTML_PRINT @"要添加哪个列？（<font color='lime'>此颜色表示已添加</font>）"

PRINTL

;プリセット一覧作成
FOR CNT_0 , 0 , VARSIZE("L_PRESET_PRINTNAME")
	;プリセット設定部
	SELECTCASE CNT_0
		CASE 0
			L_PRESET_PRINTNAME:CNT_0 = 性素质系
			{
				L_PRESET_FUNCNAME:CNT_0:0 '= 
					"处女" , 
					"Ｃ感度" , 
					"Ｖ感度" , 
					"Ａ感度" , 
					"Ｂ感度" , 
					"Ｍ感度" , 
					"灵舌" , 
					"灵活手指" , 
					"自慰" , 
					"中毒" , 
					"回应快感"
			}
			{
				L_PRESET_NAME:CNT_0:0 '= 
					"" , 
					"Ｃ感度(素质)" , 
					"Ｖ感度(素质)" , 
					"Ａ感度(素质)" , 
					"Ｂ感度(素质)" , 
					"Ｍ感度(素质)"
			}
		CASE 1
			L_PRESET_PRINTNAME:CNT_0 = 能力系
			{
				L_PRESET_FUNCNAME:CNT_0:0 '= 
					"清扫技能" , 
					"话术技能" , 
					"战斗能力" , 
					"教养" , 
					"料理技能" , 
					"音乐技能" , 
					"钓鱼Lv" , 
					"采集Lv" , 
					"调合Lv"
			}
		CASE 2
			L_PRESET_PRINTNAME:CNT_0 = 性能力系
			{
				L_PRESET_FUNCNAME:CNT_0:0 '= 
					"顺从" , 
					"欲望" , 
					"技巧" , 
					"Ｃ感觉" , 
					"Ｖ感觉" , 
					"Ａ感觉" , 
					"Ｂ感觉" , 
					"Ｍ感觉" , 
					"侍奉精神" , 
					"露出癖" , 
					"指" , 
					"舌" , 
					"胸" , 
					"腰" , 
					"膣" , 
					"Ａ" , 
					"淫乱"
			}
			{
				L_PRESET_NAME:CNT_0:0 '= 
					"" , 
					"" , 
					"" , 
					"Ｃ感觉(能力)" , 
					"Ｖ感觉(能力)" , 
					"Ａ感觉(能力)" , 
					"Ｂ感觉(能力)" , 
					"Ｍ感觉(能力)" , 
					"" , 
					"" , 
					"指技" , 
					"舌技" , 
					"胸技" , 
					"腰技" , 
					"膣技" , 
					"Ａ技" , 
					""
			}
		CASE 3
			L_PRESET_PRINTNAME:CNT_0 = 刻印系
			{
				L_PRESET_FUNCNAME:CNT_0:0 '= 
					"苦痛刻印" , 
					"快乐刻印" , 
					"顺从刻印" , 
					"反感刻印" , 
					"时奸刻印"
			}
		CASE 4
			L_PRESET_PRINTNAME:CNT_0 = 体力·气力系
			{
				L_PRESET_FUNCNAME:CNT_0:0 '= 
					"体力" , 
					"气力" , 
					"积攒度"
			}
		CASE 5
			L_PRESET_PRINTNAME:CNT_0 = 亲密度系
			{
				L_PRESET_FUNCNAME:CNT_0:0 '= 
					"好感度" , 
					"信赖度" , 
					"亲密" , 
					"关系性"
			}
			{
				L_PRESET_NAME:CNT_0:0 '= 
					"" , 
					"" , 
					"" , 
					"关系性"
			}
			; , "思慕" , "恋慕" , "恋人" , "炮友" , "愛欲"
			;↑关系性に統合したのでコメントアウトするが、禁止する理由も無いので必要なら復帰させて
		CASE 6
			L_PRESET_PRINTNAME:CNT_0 = 其他系
			{
				L_PRESET_FUNCNAME:CNT_0:0 '= 
					"弹幕胜利" , 
					"斗虫胜利" , 
					"料理胜利" , 
					"种族概要" , 
					"种族概要追加" , 
					"生理周期" , 
					"发情" , 
					"胸围" , 
					"臀围"
			}
		CASEELSE
			CONTINUE
	ENDSELECT
			
	PRINTFORML <------%L_PRESET_PRINTNAME:CNT_0%------>
	PRINT 　　

	VARSET L_TEMPS
	FOR CNT_1 , 0 , VARSIZE("L_PRESET_NAME" , 1)
		;まずボタンだけ作成
		L_RS = [\@STRLENS(L_PRESET_NAME:CNT_0:CNT_1) == 0 ? %L_PRESET_FUNCNAME:CNT_0:CNT_1% # %L_PRESET_NAME:CNT_0:CNT_1% \@]

		;現在扱っているカラム名が既に存在していたら着色かつボタンにしない。存在してないならボタンにする
		CALLFORM DEFINE_COLUMN_%L_PRESET_FUNCNAME:CNT_0:CNT_1%(DEF_COLUMN_NAME)
		FOR CNT_2 , 0 , MAX_COLUMN
			IF COLUMN_NAME:ARG_COLG:CNT_2 == RESULTS
				L_RS = <nonbutton><font color='lime'>%L_RS%</font></nonbutton>
				BREAK
			ELSEIF CNT_2 == MAX_COLUMN - 1
				;最終試行まで来たらこの列は列グループに存在してないのでボタンにする
				L_RS = <button value='%C_BUTTON_PRESET%%L_PRESET_FUNCNAME:CNT_0:CNT_1%'>%L_RS%</button>
			ENDIF
		NEXT

		HTML_PRINT L_RS , 1

		;最終試行なら改行して終了
		IF CNT_1 == VARSIZE("L_PRESET_NAME" , 1) - 1 || STRLENS(L_PRESET_FUNCNAME:CNT_0:(CNT_1 + 1)) == 0
			PRINTL 
			PRINTL 
			BREAK
		ELSE
			PRINT 　
		ENDIF
	NEXT
NEXT

DRAWLINE

;改名选项
L_TEMPS = <p align='center'>
IF COLUMN_GROUP_NAME_FIX:ARG_COLG
	L_TEMPS += @"<font color='gray'>"
	L_TEMPS += @"<nonbutton title='此列组无法重命名'>[重命名此列组]</nonbutton>　　　　"
	L_TEMPS += @"<nonbutton title='此列组无法删除'>[删除此列组]</nonbutton>"
	L_TEMPS += @"</font></p>"
ELSE
	L_TEMPS += @"<button value='%C_BUTTON_CHANGE_CGROUP_NAME%'>[重命名此列组]</button>　　　　"
	L_TEMPS += @"<button value='%C_BUTTON_REMOVE_CGROUP%'>[删除此列组]</button>"
	L_TEMPS += @"</p>"
ENDIF

HTML_PRINT L_TEMPS
PRINTL 

;编辑结束选项
;要退出此函数，此列组必须至少有一个列
FOR CNT_0 , 0 , MAX_COLUMN
	IF STRLENS(COLUMN_NAME:ARG_COLG:CNT_0) > 0
		HTML_PRINT @"<p align='center'><button value='%C_BUTTON_END%'>[结束编辑]</button></p>"
		BREAK
	ELSEIF CNT_0 == MAX_COLUMN - 1
		HTML_PRINT @"<p align='center'><font color='gray'><nonbutton title='无法结束处理。列组至少需要一个列'>[结束编辑]</nonbutton></font></p>"
	ENDIF
NEXT

DRAWLINE
PRINTL （点击选项）

L_LC:1 = LINECOUNT
$INPUT_LOOP
CLEARLINE LINECOUNT - L_LC:1

CALL INPUTS_NO_BRANK()
L_RS '= RESULTS

IF STRCOUNT(L_RS , C_BUTTON_PRESET) > 0
	L_RS '= REPLACE(L_RS , C_BUTTON_PRESET , "")
	;既に存在していないか検索
	FOR CNT_0 , 0 , MAX_COLUMN
		SIF COLUMN_NAME:ARG_COLG:CNT_0 == L_RS
			GOTO PRINT_COLUMN_LIST
	NEXT

	;为了判断是否存在，实际调用一下
	TRYCCALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_TYPE)
		;检查ARG_COLG的列组是否有空余
		L_ARRAYNUM = -1
		FOR CNT_0 , 0 , VARSIZE("COLUMN_NAME" , 1)
			IF STRLENS(COLUMN_NAME:ARG_COLG:CNT_0) == 0
				L_ARRAYNUM = CNT_0
				BREAK
			ENDIF
		NEXT
		IF GROUPMATCH(RESULT , 1 , 14) && MAX_COLUMN - L_ARRAYNUM < 2
			;如果TYPE=1，并且列记录数组只剩下最后一个空位，则无法添加，因此结束
			PRINTFORMW 没有空余的变量来记录体力·最大体力这种使用两个值的列
			GOTO INPUT_LOOP
		ENDIF
	CATCH
		;#;PRINTFORMW 列名「%L_RS%」的定义函数不存在
		GOTO INPUT_LOOP
	ENDCATCH

	;設定値を呼び出して変数へ
	CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_TYPE)
	COLUMN_TYPE:ARG_COLG:L_ARRAYNUM = RESULT
	CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_NAME)
	COLUMN_NAME:ARG_COLG:L_ARRAYNUM '= RESULTS
	CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_VAR)
	COLUMN_VAR:ARG_COLG:L_ARRAYNUM '= RESULTS
	;列の長さはASC/DESC記号があるので設定より2長くする
	CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_LEN)
	IF RESULT <= 0
		;列の長さが0以下なら列名を計測してそれを長さとして采用
		COLUMN_LEN:ARG_COLG:L_ARRAYNUM = STRLENS(COLUMN_NAME:ARG_COLG:L_ARRAYNUM) + 2
	ELSE
		;定義関数で列の長さが設定されている場合
		COLUMN_LEN:ARG_COLG:L_ARRAYNUM = RESULT + 2
	ENDIF

	;TYPE=1、14は次の配列にも内容を記録
	IF COLUMN_TYPE:ARG_COLG:L_ARRAYNUM == 1
		L_ARRAYNUM++
		CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_TYPE)
		COLUMN_TYPE:ARG_COLG:L_ARRAYNUM = RESULT
		CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_NAME)
		COLUMN_NAME:ARG_COLG:L_ARRAYNUM '= RESULTS:1
		CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_VAR)
		COLUMN_VAR:ARG_COLG:L_ARRAYNUM '= RESULTS:1
		CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_LEN)
		IF RESULT <= 0
			COLUMN_LEN:ARG_COLG:L_ARRAYNUM = STRLENS(COLUMN_NAME:ARG_COLG:L_ARRAYNUM) + 2
		ELSE
			COLUMN_LEN:ARG_COLG:L_ARRAYNUM = RESULT + 2
		ENDIF
	ELSEIF COLUMN_TYPE:ARG_COLG:L_ARRAYNUM == 14
		L_ARRAYNUM++
		CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_TYPE)
		COLUMN_TYPE:ARG_COLG:L_ARRAYNUM = RESULT
		CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_NAME)
		COLUMN_NAME:ARG_COLG:L_ARRAYNUM '= DEF_SORT_FOR_14 + RESULTS:1
		CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_VAR)
		COLUMN_VAR:ARG_COLG:L_ARRAYNUM '= RESULTS:1
		CALLFORM DEFINE_COLUMN_%L_RS%(DEF_COLUMN_LEN)
		IF RESULT <= 0
			COLUMN_LEN:ARG_COLG:L_ARRAYNUM = STRLENS(COLUMN_NAME:ARG_COLG:L_ARRAYNUM) + 2
		ELSE
			COLUMN_LEN:ARG_COLG:L_ARRAYNUM = RESULT + 2
		ENDIF
	ENDIF

	PRINTFORMW 已添加列预设「\@STRLENS(L_PRESET_NAME:ARG_COLG:TOINT(L_RS)) == 0 ? %L_RS% # %L_PRESET_NAME:ARG_COLG:TOINT(L_RS)% \@」
	L_RESULT++
	GOTO PRINT_COLUMN_LIST
ELSEIF STRCOUNT(L_RS , C_BUTTON_REMOVE_COLUMN) > 0
	;列的删除处理

	L_RS '= REPLACE(L_RS , C_BUTTON_REMOVE_COLUMN , "")
	;如果选择超出数组范围、列名为空（指定了未使用的地方）、列有固定标记，则无效
	SIF ISNUMERIC(L_RS) == 0 || INRANGE(TOINT(L_RS) , 0 , MAX_COLUMN) == 0 || STRLENS(COLUMN_NAME:ARG_COLG:TOINT(L_RS)) == 0 || COLUMN_IS_FIX:ARG_COLG:TOINT(L_RS)
		GOTO PRINT_COLUMN_LIST

	PRINTFORML 确定要删除列「%COLUMN_NAME:ARG_COLG:TOINT(L_RS)%」吗？
	PRINTL 

	CALL ASK_YN
	IF RESULT == 0
		VARSET L_TARGETCOL , -1
		L_TARGETCOL:0 = TOINT(L_RS)
		L_TARGETCOL:1 = COLUMN_PAIR(ARG_COLG , L_TARGETCOL)

		;在此之后，L_TARGETCOL可能会变动，所以先显示删除信息
		PRINTFORML 已删除列「%COLUMN_NAME:ARG_COLG:L_TARGETCOL%」
		IF INRANGE(L_TARGETCOL:1 , 0 , MAX_COLUMN)
			PRINTFORMW 配对设置的列「%COLUMN_NAME:ARG_COLG:(L_TARGETCOL:1)%」也一并删除了
		ELSE
			WAIT
		ENDIF

		;始终从数组元素的末尾开始处理
		SIF L_TARGETCOL:0 < L_TARGETCOL:1
			SWAP L_TARGETCOL:0 , L_TARGETCOL:1

		DO
			;如果是排序、筛选的列则清除
			CALLF REMOVE_SORT(FINDELEMENT(SORT_TARGET , COLUMN_NAME:ARG_COLG:L_TARGETCOL))
			CALLF REMOVE_FILTER(FINDELEMENT(FILTER_TARGET , COLUMN_NAME:ARG_COLG:L_TARGETCOL))

			;删除列
			FOR CNT_0 , L_TARGETCOL , MAX_COLUMN
				;将要删除的列移到数组末尾，并在最后一次尝试中删除数组末尾元素
				IF CNT_0 == MAX_COLUMN - 1
					COLUMN_NAME:ARG_COLG:CNT_0 = 
					COLUMN_VAR:ARG_COLG:CNT_0 = 
					COLUMN_TYPE:ARG_COLG:CNT_0 = 0
					COLUMN_LEN:ARG_COLG:CNT_0 = 0
				ELSE
					SWAP COLUMN_NAME:ARG_COLG:CNT_0 , COLUMN_NAME:ARG_COLG:(CNT_0 + 1)
					SWAP COLUMN_VAR:ARG_COLG:CNT_0 , COLUMN_VAR:ARG_COLG:(CNT_0 + 1)
					SWAP COLUMN_TYPE:ARG_COLG:CNT_0 , COLUMN_TYPE:ARG_COLG:(CNT_0 + 1)
					SWAP COLUMN_LEN:ARG_COLG:CNT_0 , COLUMN_LEN:ARG_COLG:(CNT_0 + 1)
				ENDIF
			NEXT

			ARRAYSHIFT L_TARGETCOL , -1 , -1

		LOOP L_TARGETCOL:0 != -1
		L_RESULT++
	ENDIF
	GOTO PRINT_COLUMN_LIST
ELSEIF STRCOUNT(L_RS , C_BUTTON_CHANGE_CGROUP_NAME) > 0
	;重命名此列组
	;如果此列有禁止修改标记则返回
	SIF COLUMN_GROUP_NAME_FIX:ARG_COLG
		GOTO PRINT_COLUMN_LIST
	PRINTFORML 请输入此列组的名称。输入空字符串将中止重命名
	PRINTFORML 当前设置名称：%COLUMN_GROUP_NAME:ARG_COLG%

	L_LC:2 = LINECOUNT
	$INPUT_LOOP2
	CLEARLINE LINECOUNT - L_LC:2

	INPUTS

	IF STRLENS(RESULTS) == 0
		GOTO PRINT_COLUMN_LIST
	ELSE
		PRINTFORML 输入名称为%RESULTS%。确定要将其设置为列组名称吗？
		CALL ASK_YN
		IF RESULT == 0
			PRINTW 已设置
			COLUMN_GROUP_NAME:ARG_COLG '= RESULTS
			L_RESULT++
			GOTO PRINT_COLUMN_LIST
		ELSE
			PRINTW 已取消设置。继续将再次输入名称
			GOTO INPUT_LOOP2
		ENDIF
	ENDIF
ELSEIF STRCOUNT(L_RS , C_BUTTON_REMOVE_CGROUP)
	;删除当前列组
	;如果此列有禁止修改标记则返回
	SIF COLUMN_GROUP_NAME_FIX:ARG_COLG
		GOTO PRINT_COLUMN_LIST

	PRINTFORML 确定要删除正在设置的列组「%COLUMN_GROUP_NAME:ARG_COLG%」吗？
	PRINTFORML 确定吗？
	PRINTL 

	CALL ASK_YN

	IF RESULT == 0
		;删除列组
		ARRAYSHIFT COLUMN_GROUP_NAME , -1 , "" , ARG_COLG
		ARRAYSHIFT COLUMN_GROUP_NAME_FIX , -1 , 0 , ARG_COLG

		;删除属于被删除列组的列上设置的排序和筛选器
		FOR CNT_0 , 0 , MAX_COLUMN
			SIF STRLENS(COLUMN_NAME:ARG_COLG:CNT_0) == 0
				CONTINUE
			CALLF REMOVE_FILTER(FINDELEMENT(FILTER_TARGET , COLUMN_NAME:ARG_COLG:CNT_0))
			CALLF REMOVE_SORT(FINDELEMENT(SORT_TARGET , COLUMN_NAME:ARG_COLG:CNT_0))
		NEXT

		;将列组数据向前填充一个位置，并删除末尾
		FOR CNT_0 , ARG_COLG , MAX_COLUMN_GROUP
			FOR CNT_1 , 0 , MAX_COLUMN
				IF CNT_0 < MAX_COLUMN_GROUP - 1
					COLUMN_VAR:CNT_0:CNT_1 '= COLUMN_VAR:(CNT_0 + 1):CNT_1
					COLUMN_NAME:CNT_0:CNT_1 '= COLUMN_NAME:(CNT_0 + 1):CNT_1
					COLUMN_TYPE:CNT_0:CNT_1 = COLUMN_TYPE:(CNT_0 + 1):CNT_1
					COLUMN_LEN:CNT_0:CNT_1 = COLUMN_LEN:(CNT_0 + 1):CNT_1
					COLUMN_IS_FIX:CNT_0:CNT_1 = COLUMN_IS_FIX:(CNT_0 + 1):CNT_1
				ELSE
					COLUMN_VAR:CNT_0:CNT_1 = 
					COLUMN_NAME:CNT_0:CNT_1 = 
					COLUMN_TYPE:CNT_0:CNT_1 = 0
					COLUMN_LEN:CNT_0:CNT_1 = 0
					COLUMN_IS_FIX:CNT_0:CNT_1 = 0
				ENDIF
			NEXT
		NEXT
		PRINTFORMW 已删除此列组。将返回上一画面。
		RETURN 1
	ELSE
		GOTO PRINT_COLUMN_LIST
	ENDIF
ELSEIF STRCOUNT(L_RS , C_BUTTON_END) > 0
	;编辑结束
	RETURN L_RESULT
ELSE
	GOTO INPUT_LOOP
ENDIF

GOTO INPUT_LOOP


;删除当前选定列组中的列
;2025/9/24 已整合到列组编辑函数中
@LIST_BY_DT_DELETE_COLUMN(ARG_COLG = 0)
#DIM ARG_COLG
#DIM L_LC
#DIM DYNAMIC L_IS_DELETE
#DIM CNT
#DIMS L_BUTTON
#DIMS L_BUTTON_TEMP
#DIMS L_RS
#DIMS CONST C_BUTTON_COL = "COLUMN_NUMBER_"
#DIMS CONST C_BUTTON_END = "BUTTON_CANCEL"

L_BUTTON = 
FOR CNT , 0 , MAX_COLUMN
	IF STRLENS(COLUMN_NAME:ARG_COLG:CNT) > 0
		IF COLUMN_IS_FIX:ARG_COLG:CNT
			L_BUTTON_TEMP = <font color='gray'><nonbutton title='此列已固定'>[%COLUMN_NAME:ARG_COLG:CNT%]</nonbutton></font>
		ELSE
			L_BUTTON_TEMP = <button value='%C_BUTTON_COL%{CNT}'>[%COLUMN_NAME:ARG_COLG:CNT%]</button>
		ENDIF

		IF STRLENS(L_BUTTON)
			L_BUTTON += "　　" + L_BUTTON_TEMP
		ELSE
			L_BUTTON '= L_BUTTON_TEMP
		ENDIF
	ENDIF
NEXT

IF STRLENS(L_BUTTON) == 0
	PRINTFORMW 此页面没有可删除的列。返回
	RETURN 0
ENDIF

DRAWLINE

PRINTFORML 要删除哪个列？
PRINTL 
HTML_PRINT L_BUTTON
PRINTL 

PRINTBUTTON @"[结束删除]" , C_BUTTON_END
PRINTL 

DRAWLINE

L_LC = LINECOUNT
$INPUT_LOOP
CLEARLINE LINECOUNT - L_LC
CALL INPUTS_NO_BRANK
L_RS '= RESULTS

IF STRCOUNT(L_RS , C_BUTTON_COL)
	L_RS '= REPLACE(L_RS , C_BUTTON_COL , "")
	;如果不能数值化、数值超出列数组的第二参数范围、列名未定义、列被固定，则无效
	SIF TOINT(L_RS) == 0 || INRANGE(TOINT(L_RS) , 0 , MAX_COLUMN) == 0 || STRLENS(COLUMN_NAME:ARG_COLG:TOINT(L_RS)) == 0 || COLUMN_IS_FIX:ARG_COLG:TOINT(L_RS)
		GOTO INPUT_LOOP

	PRINTFORML 确定要删除列「%COLUMN_NAME:ARG_COLG:TOINT(L_RS)%」吗？
	;好像有可以取消的操作
	;PRINTFORML ※此操作无法撤销！
	PRINTL 

	CALL ASK_YN

	IF RESULT == 0
		PRINTFORML 已删除列「%COLUMN_NAME:ARG_COLG:TOINT(L_RS)%」
		;如果是排序、筛选的列则清除
		IF FINDELEMENT(SORT_TARGET , COLUMN_NAME:ARG_COLG:TOINT(L_RS)) >= 0
			ARRAYSHIFT FILTER_TARGET , -1 , "" , FINDELEMENT(SORT_TARGET , COLUMN_NAME:ARG_COLG:TOINT(L_RS))
			ARRAYSHIFT FILTER_NUMBER , -1 , "" , FINDELEMENT(SORT_TARGET , COLUMN_NAME:ARG_COLG:TOINT(L_RS))
			ARRAYSHIFT FILTER_OPR , -1 , "" , FINDELEMENT(SORT_TARGET , COLUMN_NAME:ARG_COLG:TOINT(L_RS))
		ENDIF
		IF FINDELEMENT(SORT_TARGET , COLUMN_NAME:ARG_COLG:TOINT(L_RS)) >= 0
			ARRAYSHIFT SORT_TARGET , -1 , "" , FINDELEMENT(SORT_TARGET , COLUMN_NAME:ARG_COLG:TOINT(L_RS))
			ARRAYSHIFT SORT_IS_ASC , -1 , 0 , FINDELEMENT(SORT_TARGET , COLUMN_NAME:ARG_COLG:TOINT(L_RS))
		ENDIF

		;カラム消去
		FOR CNT , TOINT(L_RS) , MAX_COLUMN
			IF CNT == MAX_COLUMN - 1
				COLUMN_NAME:ARG_COLG:CNT = 
				COLUMN_VAR:ARG_COLG:CNT = 
				COLUMN_TYPE:ARG_COLG:CNT = 0
				COLUMN_LEN:ARG_COLG:CNT = 0
			ELSE
				SWAP COLUMN_NAME:ARG_COLG:CNT , COLUMN_NAME:ARG_COLG:(CNT + 1)
				SWAP COLUMN_VAR:ARG_COLG:CNT , COLUMN_VAR:ARG_COLG:(CNT + 1)
				SWAP COLUMN_TYPE:ARG_COLG:CNT , COLUMN_TYPE:ARG_COLG:(CNT + 1)
				SWAP COLUMN_LEN:ARG_COLG:CNT , COLUMN_LEN:ARG_COLG:(CNT + 1)
			ENDIF
		NEXT

		;カラムを消去したフラグ立て、関数リスタート
		L_IS_DELETE++
		RESTART
	ELSE
		GOTO INPUT_LOOP
	ENDIF
ELSEIF STRCOUNT(L_RS , C_BUTTON_END)
	;編集終了
	RETURN L_IS_DELETE
ENDIF
GOTO INPUT_LOOP


@SET_RANK(ARG_VARNAME = "")
#FUNCTION
#DIMS ARG_VARNAME

IF ARG_VARNAME == "汎用ランク" || STRLENS(ARG_VARNAME) == 0
	ARRAYCOPY "汎用ランク" , "RESULT"
	RETURNF VARSIZE("汎用ランク")
ELSE
	ARRAYCOPY ARG_VARNAME , "RESULT"
	RETURNF VARSIZE(ARG_VARNAME)
ENDIF


@CHARALIST_DT_RELATION(ARG_CHR = -1)
#DIM ARG_CHR
;TRYCCALLFORMしたいがためだけにこの関数作った
RETURN CALC_RELATION_TALENT(ARG_CHR)


;番号のキャラとMASTERの関係について優先順を考慮して返す
;名前は配列添え字と変数の値を@GET_TALENTNAMEに渡せば取れる
;現状TALENT添え字と優先度の並びががなんとなく一致しているからいいが、一応bitも用意しておく
@CALC_RELATION_TALENT(ARG_CHR = -1)
#FUNCTION
#DIM ARG_CHR
#DIM L_TALENT_TO_BIT ;優先されるTALENTほど上位のbitを立てておく(使うか不明)
#DIM L_TALENT_NUM

;ソートの都合で、見つからなかった場合はTWで使われないであろう数を入れておく
L_TALENT_NUM = DEF_CULC_RELATION_NULL
L_TALENT_TO_BIT = 0

;@TEMP_CHARA_BUTTONより
IF TALENT:ARG_CHR:恋人
	SETBIT L_TALENT_TO_BIT , TOINT(CALC_RELATION_TALENT_BIT( , "恋人"))
	L_TALENT_NUM = GETNUM(TALENT , "恋人")
ELSEIF TALENT:ARG_CHR:恋慕 == 2
	SETBIT L_TALENT_TO_BIT , TOINT(CALC_RELATION_TALENT_BIT( , "爱恋"))
	L_TALENT_NUM = GETNUM(TALENT , "恋慕")
ELSEIF TALENT:ARG_CHR:恋慕 == 1
	SETBIT L_TALENT_TO_BIT , TOINT(CALC_RELATION_TALENT_BIT( , "恋慕"))
	L_TALENT_NUM = GETNUM(TALENT , "恋慕")
ELSEIF TALENT:ARG_CHR:愛欲 == 1
	SETBIT L_TALENT_TO_BIT , TOINT(CALC_RELATION_TALENT_BIT( , "愛欲"))
	L_TALENT_NUM = GETNUM(TALENT , "愛欲")
ELSEIF TALENT:ARG_CHR:炮友 == 1
	SETBIT L_TALENT_TO_BIT , TOINT(CALC_RELATION_TALENT_BIT( , GET_TALENTNAME(GETNUM(TALENT , "炮友") , 1)))
	L_TALENT_NUM = GETNUM(TALENT , "炮友")
ELSEIF TALENT:ARG_CHR:炮友 == 2
	SETBIT L_TALENT_TO_BIT , TOINT(CALC_RELATION_TALENT_BIT( , GET_TALENTNAME(GETNUM(TALENT , "炮友") , 2)))
	L_TALENT_NUM = GETNUM(TALENT , "炮友")
ELSEIF TALENT:ARG_CHR:思慕 == 1
	SETBIT L_TALENT_TO_BIT , TOINT(CALC_RELATION_TALENT_BIT( , "思慕"))
	L_TALENT_NUM = GETNUM(TALENT , "思慕")
ELSE
	
ENDIF

RETURNF L_TALENT_NUM
;RETURNF L_TALENT_TO_BIT


;ARG_BITに立ったビットから該当する关系性を返す
;ARG_TNAMEから該当する关系性のビット位置を返す
;両方に何かしらの文字列と数値を同時に入れた場合、文字列(ARG_TNAME)が優先
@CALC_RELATION_TALENT_BIT(ARG_BIT = 0 , ARG_TNAME = "")
#FUNCTIONS
#DIMS ARG_TNAME
#DIM ARG_BIT
#DIMS L_TALENT_NAME , 64
#DIM CNT

L_TALENT_NAME:10 = 思慕
L_TALENT_NAME:11 = %GET_TALENTNAME(GETNUM(TALENT , "炮友") , 1)%
L_TALENT_NAME:12 = %GET_TALENTNAME(GETNUM(TALENT , "炮友") , 2)%
L_TALENT_NAME:13 = 愛欲
L_TALENT_NAME:14 = 恋慕
L_TALENT_NAME:15 = 爱恋
L_TALENT_NAME:16 = 恋人

IF STRLENS(ARG_TNAME)
	RETURNF TOSTR(FINDELEMENT(L_TALENT_NAME , ARG_TNAME ,  ,  , 1))
ELSE
	FOR CNT , 0 , 64
		SIF GETBIT(ARG_BIT , CNT)
			RETURNF L_TALENT_NAME:CNT
	NEXT
ENDIF
RETURNF ""



[SKIPSTART]
一个函数，它将DATATABLE中具有ARG_NULLWORD指定值的单元格视为无效，并将其发送到开头或末尾，然后对其他单元格进行排序。
它会应用筛选器进行筛选，并应用排序，然后将结果DATATABLE的行ID依次放入RESULT中返回。这个表达式函数本身返回命中数。
	ARG_DTNAME  :要排序的DATATABLE名称
	ARG_COLUMN  :要排序的列名。如果是空字符串，则只应用筛选器和排序就结束
	ARG_FILTER  :筛选子句
	ARG_SORT    :排序子句
	ARG_VAR     :输出目标数组
	ARG_IS_FIRST:将无效单元格置于开头的标志。非0则置于开头，0则送至末尾。默认0
	ARG_NULLWORD:视为无效单元格的关键词。默认%DEF_CELL_NULL%
附注：因为已经改为通过筛选器隐藏无效数值的处理方式，所以目前没有使用这个函数
[SKIPEND]
@DT_SELECT_NULL_IS_LAST(ARG_DTNAME = "" , ARG_COLUMN = "" , ARG_FILTER = "" , ARG_SORT = "" , ARG_VAR , ARG_IS_FIRST = 0 , ARG_NULLWORD = DEF_CELL_NULL)
#FUNCTION
#DIM REF ARG_VAR
#DIMS ARG_DTNAME
#DIMS ARG_FILTER
#DIMS ARG_SORT
#DIMS ARG_COLUMN
#DIMS ARG_NULLWORD
#DIMS L_FILTER
#DIMS L_TEMPXML
#DIM ARG_IS_FIRST
#DIM L_HITNUM
#DIM L_TEMP
#DIM CNT

L_TEMPXML = <ROOT />

IF ARG_IS_FIRST
	$LOOP1
	IF STRLENS(ARG_COLUMN) == 0
		VARSET L_FILTER
	ELSEIF STRLENS(ARG_FILTER) == 0
		L_FILTER = %ARG_COLUMN% = '%ARG_NULLWORD%'
	ELSE
		L_FILTER = %ARG_FILTER% AND %ARG_COLUMN% = '%ARG_NULLWORD%'
		;%ARG_NULLWORD%
	ENDIF

	L_HITNUM = DT_SELECT(ARG_DTNAME , L_FILTER , ARG_SORT , RESULT)

	;XML_ADDNODEはRESULT:0を壊す
	L_TEMP = RESULT
	FOR CNT , 0 , L_HITNUM
		XML_ADDNODE L_TEMPXML , @"/ROOT" , @"<id>{RESULT:CNT}</id>" , 0 , 1
	NEXT
	SWAP L_TEMP , RESULT

	;DEBUGPRINTFORML 1.ヒット数は{L_HITNUM},XMLノード数は{XML_GET(L_TEMPXML , @"/ROOT/id")}だよ
	IF STRLENS(ARG_COLUMN) == 0
		GOTO SKIP_IF
	ELSEIF ARG_IS_FIRST
		GOTO LOOP2
	ENDIF
ELSE
	$LOOP2
	IF STRLENS(ARG_COLUMN) == 0
		VARSET L_FILTER
	ELSEIF STRLENS(ARG_FILTER) == 0
		L_FILTER = %ARG_COLUMN% <> '%ARG_NULLWORD%'
	ELSE
		L_FILTER = %ARG_FILTER% AND %ARG_COLUMN% <> '%ARG_NULLWORD%'
	ENDIF

	L_HITNUM = DT_SELECT(ARG_DTNAME , L_FILTER , ARG_SORT , RESULT)

	;XML_ADDNODEはRESULT:0を壊す
	L_TEMP = RESULT
	FOR CNT , 0 , L_HITNUM
		XML_ADDNODE L_TEMPXML , @"/ROOT" , @"<id>{RESULT:CNT}</id>" , 0 , 1
	NEXT
	SWAP L_TEMP , RESULT

	;DEBUGPRINTFORML 2.ヒット数は{L_HITNUM},XMLノード数は{XML_GET(L_TEMPXML , @"/ROOT/id")}だよ
	IF STRLENS(ARG_COLUMN) == 0
		GOTO SKIP_IF
	ELSEIF ARG_IS_FIRST == 0
		GOTO LOOP1
	ENDIF
ENDIF

$SKIP_IF
L_HITNUM = XML_GET(L_TEMPXML , @"/ROOT/id/text()" , RESULTS)
FOR CNT , 0 , L_HITNUM
	ARG_VAR:CNT = TOINT(RESULTS:CNT)
NEXT

;ARG_IS_FIRST = XML_GET(L_TEMPXML , @"/ROOT/id")
VARSET L_TEMPXML

RETURNF L_HITNUM


[SKIPSTART]
ARG_STRに渡された文字列をARG_SPLITWORDでSPLITを実行、ARG_TARGETPOSに相当する位置の文字列だけ返す式中関数
	ARG_STR      :分割の対象となる文字列
	ARG_TARGETPOS:返して欲しい文字列の位置。0から始まる。該当がない時は空文字を返す
	ARG_SPLITWORD:分割する文字列。既定はカンマ。空文字不可
[SKIPEND]
@TARGET_SPLIT(ARG_STR = "" , ARG_TARGETPOS = -1 , ARG_SPLITWORD = ",")
#FUNCTIONS
#DIMS ARG_STR
#DIMS ARG_SPLITWORD
#DIMS L_SPLITSTR , 100
#DIM ARG_TARGETPOS
#DIM L_TEMP
#DIM CNT

SIF STRLENS(ARG_SPLITWORD) == 0
	THROW 分割キーワードが与えられていません
SIF STRLENS(ARG_STR) == 0
	RETURNF ""

L_TEMP = RESULT

SPLIT ARG_STR , ARG_SPLITWORD , L_SPLITSTR

SWAP L_TEMP , RESULT

IF INRANGE(ARG_TARGETPOS , 0 , L_TEMP - 1) == 0
	;ARG_TARGETPOSが指している分割対象物がないなら空文字を返却
	RETURNF ""
ELSEIF L_TEMP == 1
	;分割キーワードが対象文字列に存在しないならそのまま返す(ここに来ているならARG_TARGETPOSは0)
	RETURNF ARG_STR
ELSE
	;分割キーワードがあり、ARG_TARGETPOSが有効な配列を指しているなら対象の分割済み文字列を返す
	RETURNF L_SPLITSTR:ARG_TARGETPOS
ENDIF


;与えられたオプション文字列と定数CHARA_LIST_OP_CONSTを比較し、ヒットしたオプションの要素をビットとして立てる
;CHARA_LIST_OP_CONSTにはTWをgrepして見つけたオプション文字列を入れてあるが、抜けがあるかも
@CHARA_LIST_OP_TO_BIT(ARG_OPTION = "")
#FUNCTION
#DIMS ARG_OPTION
#DIM L_BITPOS
#DIM CNT

SIF STRLENS(ARG_OPTION) == 0
	RETURNF 0
;半角スペースとかタブを消しておく
ARG_OPTION '= REPLACE(ARG_OPTION , " " , "")
ARG_OPTION '= REPLACE(ARG_OPTION , "	" , "")
ARG_OPTION '= REPLACE(ARG_OPTION , "　" , "")

;定数配列CHARA_LIST_OP_CONSTとARG_OPTION文字列を比較、合致したらビットを立てて合致文字列を消去する
;ビットが立つ位置は定数配列の位置と同じ、つまり定義順
L_BITPOS = 0
FOR CNT , 0 , VARSIZE("CHARA_LIST_OP_CONST")
	SIF STRLENS(CHARA_LIST_OP_CONST:CNT) == 0
		CONTINUE
	IF STRFIND(ARG_OPTION , CHARA_LIST_OP_CONST:CNT) >= 0
		SETBIT L_BITPOS , CNT
		ARG_OPTION '= REPLACE(ARG_OPTION , CHARA_LIST_OP_CONST:CNT , "")
	ENDIF
NEXT

;もしここまで来てARG_OPTIONが消滅しなかったらエラー
IF STRLENS(ARG_OPTION)
	THROW キャラリストのオプション"%ARG_OPTION%"は未定義です
ELSE
	RETURNF L_BITPOS
ENDIF


@CHARA_LIST_BIT_TO_OP(ARG_BIT = 0)
#FUNCTIONS
#DIM ARG_BIT
#DIM CNT
#DIMS L_OPNAME

VARSET L_OPNAME
FOR CNT , 0 , 63
	IF GETBIT(ARG_BIT , CNT)
		IF STRLENS(CHARA_LIST_OP_CONST:CNT)
			L_OPNAME += CHARA_LIST_OP_CONST:CNT
		ELSE
			THROW ARG_BITの第{CNT}ビットは未定義です
		ENDIF
	ENDIF
NEXT

RETURNF L_OPNAME


;与えられたオプション文字列に、指定された文字列が存在するか探す式中関数
;オプションとは@SHOW_CHARA_LIST(およびその派生関数)が扱う引数
;ARG_OP_STRとARG_OPは順不同
@CHARA_LIST_FIND_OP(ARG_OP_STR = "" , ARG_OP = "")
#FUNCTION
#DIMS ARG_OP
#DIMS ARG_OP_STR
#DIM L_BIT
#DIM L_STRBIT

L_STRBIT = CHARA_LIST_OP_TO_BIT(ARG_OP_STR)
L_BIT = CHARA_LIST_OP_TO_BIT(ARG_OP)

RETURNF L_BIT & L_STRBIT


;[AAA]     [BBB]      [CCCCC]  [DDDD]
;↑こんな感じで行の中央に指定した分の空白を置き、その左右にボタンを設置していく関数
;ARG_CENTER_BRANK = 中央に設置される半角スペースの数
;ARG_SPRIT_WORD = LEFT_BUTTON、RIGHT_BUTTONに渡される文字列を、ボタン表示文字列とボタンの値文字列とに分割する区切り
;ARG_LEFT_BUTTON、ARG_RIGHT_BUTTON = ボタンとして表示される文字列、及びボタンを押したときに返される文字列を受け取る
;                                    表記は(ボタン表示文字列)%ARG_SPLIT_WORD%(ボタン値文字列)
@BUTTON_CENTER_TO_EDGE_STR(ARG_LEFT_BUTTON , ARG_RIGHT_BUTTON , ARG_CENTER_BRANK = 8 , ARG_SPLIT_WORD = ":,:")
#DIMS REF ARG_LEFT_BUTTON
#DIMS REF ARG_RIGHT_BUTTON
#DIM ARG_CENTER_BRANK
#DIMS ARG_SPLIT_WORD
#DIMS L_HTMLSTR
#DIM L_MAXLEN
#DIM L_LEFTNUM
#DIM L_RIGHTNUM
#DIM CNT

;選択肢の最大長割り出し
VARSET L_MAXLEN
VARSET L_LEFTNUM
VARSET L_RIGHTNUM
FOR CNT , 0 , VARSIZE(ARG_LEFT_BUTTON)
	IF STRLENS(TARGET_SPLIT(ARG_LEFT_BUTTON:CNT , 0 , ARG_SPLIT_WORD)) > 0
		L_MAXLEN = MAX(L_MAXLEN , STRLENS(TARGET_SPLIT(ARG_LEFT_BUTTON:CNT , 0 , ARG_SPLIT_WORD)))
		L_LEFTNUM++
	ENDIF
NEXT

FOR CNT , 0 , VARSIZE(ARG_RIGHT_BUTTON)
	IF STRLENS(TARGET_SPLIT(ARG_RIGHT_BUTTON:CNT , 0 , ARG_SPLIT_WORD)) > 0
		L_MAXLEN = MAX(L_MAXLEN , STRLENS(TARGET_SPLIT(ARG_RIGHT_BUTTON:CNT , 0 , ARG_SPLIT_WORD)))
		L_RIGHTNUM++
	ENDIF
NEXT

;画面最大幅の半分から中央空白幅の半分を引き(=左選択肢の表示領域)、そこから選択肢最大長*左選択肢の個数を引く
PRINT_RECT MAXWIDTH() / 2 - ARG_CENTER_BRANK / 2 - L_MAXLEN * L_LEFTNUM

;表示処理
FOR CNT , 0 , VARSIZE(ARG_LEFT_BUTTON)
	PRINTBUTTON @"%TARGET_SPLIT(ARG_LEFT_BUTTON:CNT , 0 , ARG_SPLIT_WORD) , L_MAXLEN , RIGHT%" , TARGET_SPLIT(ARG_LEFT_BUTTON:CNT , 1 , ARG_SPLIT_WORD)
NEXT

PRINTFORM %" " * ARG_CENTER_BRANK%

FOR CNT , 0 , VARSIZE(ARG_RIGHT_BUTTON)
	PRINTBUTTON @"%TARGET_SPLIT(ARG_RIGHT_BUTTON:CNT , 0 , ARG_SPLIT_WORD) , L_MAXLEN , LEFT%" , TARGET_SPLIT(ARG_RIGHT_BUTTON:CNT , 1 , ARG_SPLIT_WORD)
NEXT

RETURN (L_LEFTNUM + L_RIGHTNUM) * L_MAXLEN + ARG_CENTER_BRANK


;@ESTRUS_CATEGORYの返す文字列に特定の加工をして返す
;排卵誘発剤が長いとか、危険日をハートマークで囲いたいとか
@ESTRUS_CATEGORY_STR(ARG_CHR = -1 , ARG_DAY = 0)
#DIM ARG_CHR
#DIM ARG_DAY
RESULTS '= ESTRUS_CATEGORY(ARG_CHR)
;以下ちょっと加工する
SELECTCASE RESULTS
	CASE "排卵诱发剂生效中"
		RESULTS = 排卵剂
	;CASE "危险日"
	;	RESULTS '= UNICODE(0x2665) + RESULTS + UNICODE(0x2665)
ENDSELECT
RETURN 1


;そのキャラの種族を判定し、一つの文字列にまとめてRESULTSに入れる関数
;TALENT:追加種族は別関数で扱う
@CHARA_TRIBE_STR(ARG_CHR = -1 , ARG_CONNECTWORD = "、")
#DIM ARG_CHR
;左から順に判定し、文字列に付け加えていく
{
	#DIM CONST C_REF_TALENT = 
		GETNUM(TALENT, "人类") , 
		GETNUM(TALENT, "妖怪") , 
		GETNUM(TALENT, "妖精") , 
		GETNUM(TALENT, "神霊") , 
		GETNUM(TALENT, "幽霊") , 
		GETNUM(TALENT, "付喪神") , 
		GETNUM(TALENT, "人形")
}
#DIM CNT
#DIM L_HITNUM
#DIMS L_TEMPS
#DIMS ARG_CONNECTWORD

RESULTS = 
L_HITNUM = 0
FOR CNT , 0 , VARSIZE("C_REF_TALENT")
	L_TEMPS '= GET_TRIBENAME(ARG_CHR , C_REF_TALENT:CNT)
	;TALENTの参照は非0のものだけ
	IF TALENT:ARG_CHR:(C_REF_TALENT:CNT) && STRLENS(L_TEMPS) > 0
		L_HITNUM++
		IF STRLENS(RESULTS) == 0
			RESULTS '= L_TEMPS
		ELSE
			RESULTS += ARG_CONNECTWORD + L_TEMPS
		ENDIF
	ENDIF
NEXT
RETURN L_HITNUM


;そのキャラの追加種族を判定し、一つの文字列にまとめてRESULTSに入れる関数
@CHARA_TRIBE_STR_OPTION(ARG_CHR = -1 , ARG_CONNECTWORD = "、")
#DIM ARG_CHR
;左から順に判定し、文字列に付け加えていく
{
	#DIM CONST C_REF_TALENT = 
		GETNUM(TALENT, "追加種族") , 
}
#DIM CNT
#DIM L_HITNUM
#DIMS L_TEMPS
#DIMS ARG_CONNECTWORD

RESULTS = 
L_HITNUM = 0
FOR CNT , 0 , VARSIZE("C_REF_TALENT")
	L_TEMPS '= GET_TRIBENAME(ARG_CHR , C_REF_TALENT:CNT)
	;TALENTの参照は非0のものだけ
	IF TALENT:ARG_CHR:(C_REF_TALENT:CNT) && STRLENS(L_TEMPS) > 0
		L_HITNUM++
		IF STRLENS(RESULTS) == 0
			RESULTS '= L_TEMPS
		ELSE
			RESULTS += ARG_CONNECTWORD + L_TEMPS
		ENDIF
	ENDIF
NEXT
RETURN L_HITNUM


;CHARA_TRIBE_STRが返す文字列、および種族ヒット数からそのセルのソート用点数を返す関数
;ヒット数→同じ文字列の順で並ぶように点数を调整する
@CHARA_TRIBE_STR_SCORE(ARG_CHR = -1)
#DIM ARG_CHR
#DIM L_HITNUM
#DIMS L_TEMPS
#DIMS CONST C_CONNECTWORD = "、"

CALL CHARA_TRIBE_STR(ARG_CHR)
;L_TEMPS '= RESULTS
L_TEMPS = 
L_HITNUM = RESULT

RETURN STR_AND_HITNUM_TO_SCORE(L_TEMPS , L_HITNUM)


;列定義を見て、それが文字列に設定されているかどうか取得する関数
@COLUMN_IS_STR(ARG_DEF_COLNAME = "")
#DIMS ARG_DEF_COLNAME

CALLFORM DEFINE_COLUMN_%ARG_DEF_COLNAME%
RETURN TOUPPER(TARGET_SPLIT(RESULTS , 2)) == DEF_COLUMN_IS_STR


;ARG_COLUMN_NAMEに与えられたDT列がペア扱いされるかどうか判定して返す関数。ARG_POSは何個目にヒットした列を見るか返す
;返り値
;	RESULTS = ペア扱いされている列の名前が入る
;	RETURNF = 渡された列名の位置(COLUMN_NAMEの第二要素。ペアが見つからない、あるいはペア扱いされていない場合-1)
@COLUMN_PAIR(ARG_CGROUP_POS = -1 , ARG_COLUMN_POS = -1)
#FUNCTION
#DIM ARG_COLUMN_POS
#DIM ARG_CGROUP_POS
#DIM CNT_0
#DIM CNT_1
#DIM L_COLUMN_TYPE
#DIM L_TEMP

;ペア列扱いされていない、列の最大値が1に設定されている場合は終了
IF DEFINE_COLUMN_PAIR(COLUMN_TYPE:ARG_CGROUP_POS:ARG_COLUMN_POS) == 0 || MAX_COLUMN <= 1
	RESULTS = 
	RETURNF -1
ENDIF

;渡されたARG_COLUMN_NAMEのCOLUMN_TYPEを記録しておく
L_COLUMN_TYPE = COLUMN_TYPE:ARG_CGROUP_POS:ARG_COLUMN_POS

IF ARG_COLUMN_POS == 0
	;もし配列の先頭要素ならすぐ後ろの要素だけを検証して返す
	IF COLUMN_TYPE:ARG_CGROUP_POS:(ARG_COLUMN_POS + 1) == L_COLUMN_TYPE
		RESULTS '= COLUMN_NAME:ARG_CGROUP_POS:(ARG_COLUMN_POS + 1)
		RETURNF ARG_COLUMN_POS + 1
	ELSE
		RESULTS = 
		RETURNF -1
	ENDIF
ELSEIF ARG_COLUMN_POS == MAX_COLUMN - 1
	;もし配列の最後尾要素ならすぐ前の要素だけを検証して返す
	IF COLUMN_TYPE:ARG_CGROUP_POS:(ARG_COLUMN_POS - 1) == L_COLUMN_TYPE
		RESULTS '= COLUMN_NAME:ARG_CGROUP_POS:(ARG_COLUMN_POS - 1)
		RETURNF ARG_COLUMN_POS - 1
	ELSE
		RESULTS = 
		RETURNF -1
	ENDIF
ELSE
	L_TEMP = 0
	FOR CNT_0 , 1 , MAX_COLUMN - 1
		;L_TEMPが0の状態でARG_COLUMN_NAMEを見つけたら直後を検証して返す。L_TEMPが1の状態でARG_COLUMN_NAMEを見つけたら直前を検証して返す
		IF CNT_0 == ARG_COLUMN_POS && DEFINE_COLUMN_PAIR(COLUMN_TYPE:ARG_CGROUP_POS:CNT_0)
			IF L_TEMP == 0
				RESULTS '= COLUMN_NAME:ARG_CGROUP_POS:(CNT_0 + 1)
				RETURNF CNT_0 + 1
			ELSE
				RESULTS '= COLUMN_NAME:ARG_CGROUP_POS:(CNT_0 - 1)
				RETURNF CNT_0 - 1
			ENDIF
		ELSEIF COLUMN_TYPE:ARG_CGROUP_POS:CNT_0 == L_COLUMN_TYPE
			;もしARG_COLUMN_NAMEのTYPEと同じTYPEが見つかったらL_TEMPを否定する
			L_TEMP = !L_TEMP
		ENDIF
	NEXT
ENDIF

RESULTS = 
RETURNF -1


;ARG_COLUMN_TYPEに渡された列がペア扱いされるTYPEかどうか判定して返す式中間数
;ARG_ALL_COLUMN_TYPEに非0を渡すとRESULTにペア扱いされるすべての列のTYPEを入れる。この関数自体は対象のTYPEの総数を返す
;PAIR_COLUMN_TYPEはグローバル定数
@DEFINE_COLUMN_PAIR(ARG_COLUMN_TYPE = -1 , ARG_ALL_COLUMN_TYPE = 0)
#FUNCTION
#DIM ARG_COLUMN_TYPE
#DIM ARG_ALL_COLUMN_TYPE
#DIM CNT

IF ARG_ALL_COLUMN_TYPE
	FOR CNT , 0 , VARSIZE("PAIR_COLUMN_TYPE")
		RESULT:CNT = PAIR_COLUMN_TYPE:CNT
	NEXT
	RETURNF VARSIZE("PAIR_COLUMN_TYPE")
ENDIF

RETURNF MATCH(PAIR_COLUMN_TYPE , ARG_COLUMN_TYPE) != 0


;ARG_COLUMN_NAMEで指定された列に対してソートを設定する。
;ARG_IS_ASCに1以上を渡すと昇順で、0を渡すと降順でソートする
;ARG_IS_ASCが-1だと現在の状態から降順/昇順を設定する
@ADD_SORT(ARG_COLUMN_NAME = "" , ARG_IS_ASC = -1)
#FUNCTION
#DIMS ARG_COLUMN_NAME
#DIM ARG_IS_ASC
#DIM L_ARRAY
#DIM CNT
SIF STRLENS(ARG_COLUMN_NAME) == 0
	THROW 対象列が未設定だよ

L_ARRAY = -1
FOR CNT , 0 , LIST_MAX_SORT
	IF SORT_TARGET:CNT == ARG_COLUMN_NAME || STRLENS(SORT_TARGET:CNT) == 0
		L_ARRAY = CNT
		BREAK
	ENDIF
NEXT

IF L_ARRAY == -1
	;もしここまで来てL_ARRAYが-1なら空きがないので古いのを消して、最後尾に入れちゃう
	CALLF REMOVE_SORT(0)
	L_ARRAY = LIST_MAX_SORT - 1
	SORT_TARGET:L_ARRAY '= ARG_COLUMN_NAME
	SELECTCASE ARG_IS_ASC
		CASE 0 , -1
			SORT_IS_ASC:L_ARRAY = 0
		CASEELSE
			SORT_IS_ASC:L_ARRAY = 1
	ENDSELECT
	RETURNF L_ARRAY
ELSE
	SORT_TARGET:L_ARRAY '= ARG_COLUMN_NAME
	IF ARG_IS_ASC == -1
		SORT_IS_ASC:L_ARRAY = !SORT_IS_ASC:L_ARRAY
	ELSE
		SORT_IS_ASC:L_ARRAY = (ARG_IS_ASC != 0)
	ENDIF
	RETURNF L_ARRAY
ENDIF



;ARG_SORT_NOで渡されたソート句を削除する
;ARG_SORT_NOは配列の要素。消せたら1を、未使用なら0を、配列の外なら-1を返す
@REMOVE_SORT(ARG_SORT_NO = -1)
#FUNCTION
#DIM ARG_SORT_NO

SIF INRANGE(ARG_SORT_NO , 0 , LIST_MAX_SORT) == 0
	RETURNF -1
SIF STRLENS(SORT_TARGET:ARG_SORT_NO) == 0
	RETURNF 0

ARRAYSHIFT SORT_TARGET , -1 , "" , ARG_SORT_NO
ARRAYSHIFT SORT_IS_ASC , -1 , 0 , ARG_SORT_NO

RETURNF 1


;引数３個で定義されるフィルターをフィルター配列に入れる
;もし配列に空きがなければ古いものを一個消して最後に入れる
;もし既に同じ列に対するフィルターがあるなら評価演算子とオペランドだけ更新する
@ADD_FILTER(ARG_FILTER_TARGET = "" , ARG_FILTER_OPR = "" , ARG_FILTER_NUM = "")
#FUNCTION
#DIMS ARG_FILTER_TARGET
#DIMS ARG_FILTER_OPR
#DIMS ARG_FILTER_NUM
#DIM L_ARRAY
#DIM CNT

SIF STRLENS(ARG_FILTER_TARGET) == 0 || STRLENS(ARG_FILTER_OPR) == 0 || STRLENS(ARG_FILTER_NUM) == 0
	THROW ARG_FILTER_TARGET,OPR,NUMが未設定だよ  TARGET=%ARG_FILTER_TARGET%  OPR=%ARG_FILTER_OPR%  NUMBER=%ARG_FILTER_NUM%

L_ARRAY = FINDELEMENT(FILTER_TARGET , ARG_FILTER_TARGET)
IF L_ARRAY == -1
	FOR CNT , 0 , LIST_MAX_FILTER
		IF STRLENS(FILTER_TARGET) == 0
			L_ARRAY = CNT
			BREAK
		ENDIF
	NEXT

	;もし見つからなければ古いものを一個消し、最後尾に足す
	IF L_ARRAY == -1
		ARRAYSHIFT FILTER_TARGET , -1 , ""
		ARRAYSHIFT FILTER_OPR , -1 , ""
		ARRAYSHIFT FILTER_NUMBER , -1 , ""
		L_ARRAY = LIST_MAX_FILTER - 1
	ENDIF
ENDIF

FILTER_TARGET:L_ARRAY '= ARG_FILTER_TARGET
FILTER_OPR:L_ARRAY '= ARG_FILTER_OPR
FILTER_NUMBER:L_ARRAY '= ARG_FILTER_NUM

RETURNF L_ARRAY


;ARG_FILTER_NOで渡されたソート句を削除する
;ARG_FILTER_NOは配列の要素。消せたら1を、未使用なら0を、配列の外なら-1を返す
@REMOVE_FILTER(ARG_FILTER_NO = -1)
#FUNCTION
#DIM ARG_FILTER_NO

SIF INRANGE(ARG_FILTER_NO , 0 , LIST_MAX_FILTER) == 0
	RETURNF -1
SIF STRLENS(FILTER_TARGET:ARG_FILTER_NO) == 0
	RETURNF 0

ARRAYSHIFT FILTER_TARGET , -1 , "" , ARG_FILTER_NO
ARRAYSHIFT FILTER_OPR , -1 , "" , ARG_FILTER_NO
ARRAYSHIFT FILTER_NUMBER , -1 , "" , ARG_FILTER_NO

RETURNF 1


;ARGB形式の色とアルファを持たないRGB形式の色(背景など)を合成する
;ARG_BACK_RGBはARGB形式でもいいが、その場合はアルファは無視する
;ARG_FRONT_ARGBが手前の色、ARG_BACK_RGBが後ろ側の色
@BLEND_ARGB_RGB(ARG_FRONT_ARGB = 0x0 , ARG_BACK_RGB = 0x0)
#FUNCTION
#DIM ARG_FRONT_ARGB
#DIM ARG_BACK_RGB
#DIM L_FRONT_A
#DIM L_FRONT_RGB , 3
#DIM L_BACK_A
#DIM L_BACK_RGB , 3
#DIM L_RES_A
#DIM L_RES_RGB , 3
#DIM CNT

L_FRONT_A = ARG_FRONT_ARGB / 0x1000000
;L_BACK_Aは使わないが一応
L_BACK_A = ARG_BACK_RGB / 0x1000000

FOR CNT , 0 , 3
	L_FRONT_RGB:CNT = ARG_FRONT_ARGB / POWER(0x100 , (2 - CNT)) % 0x100
	L_BACK_RGB:CNT = ARG_BACK_RGB / POWER(0x100 , (2 - CNT)) % 0x100
NEXT

SIF INRANGE(L_FRONT_A , 0 , 0xFF) == 0 || INRANGE(L_BACK_A , 0 , 0xFF) == 0 || INRANGE(L_FRONT_RGB , 0 , 0xFFFFFF) == 0 || INRANGE(L_BACK_RGB , 0 , 0xFFFFFF) == 0
	THROW 引数の値がおかしいよ　ARG_FRONT_ARGB=%INT_TO_ARGB(ARG_FRONT_ARGB)%  ARG_BACK_RGB=%INT_TO_ARGB(ARG_BACK_RGB)%

IF L_FRONT_A == 0
	RETURNF ARG_BACK_RGB
;ELSEIF L_BACK_A == 0
;	RETURNF ARG_FRONT_ARGB
ELSEIF L_FRONT_A == 0xFF
	RETURNF ARG_FRONT_ARGB
ENDIF

L_RES_A = 0xFF

FOR CNT , 0 , 3
	L_RES_RGB:CNT = L_FRONT_RGB:CNT * L_FRONT_A / 0xFF + L_BACK_RGB:CNT * (0xFF - L_FRONT_A) / 0xFF
	L_RES_RGB:CNT = LIMIT(L_RES_RGB:CNT , 0 , 0xFF)
NEXT

RETURNF L_RES_A * 0x1000000 + L_RES_RGB:0 * 0x10000 + L_RES_RGB:1 * 0x100 + L_RES_RGB:2


;ARGB形式の色同士を合成する
;ARG_FRONT_ARGBが手前の色、ARG_BACK_RGBが後ろ側の色
;"(～ > 0xFF / 2 ? 1 # 0)"ってやっているところはあまりを四捨五入っぽく0xFFの半分より多ければ1に切り上げている("～"は小数*0xFF)
@BLEND_ARGB_ARGB(ARG_FRONT_ARGB = 0x0 , ARG_BACK_ARGB = 0x0)
#FUNCTION
#DIM ARG_FRONT_ARGB
#DIM ARG_BACK_ARGB
#DIM L_FRONT_A
#DIM L_FRONT_RGB , 3
#DIM L_BACK_A
#DIM L_BACK_RGB , 3
#DIM L_RES_A
#DIM L_RES_RGB , 3
#DIM CNT

;アルファ切り出し
L_FRONT_A = ARG_FRONT_ARGB / 0x1000000 % 0x100
L_BACK_A = ARG_BACK_ARGB / 0x1000000 % 0x100
;生成物のアルファ計算
L_RES_A = L_BACK_A * (0xFF - L_FRONT_A) / 0xFF + L_FRONT_A + (L_BACK_A * (0xFF - L_FRONT_A) % 0xFF > 0xFF / 2 ? 1 # 0)
;RGBの各成分を記録
FOR CNT , 0 , 3
	L_FRONT_RGB:CNT = ARG_FRONT_ARGB / POWER(0x100 , (2 - CNT)) % 0x100
	L_BACK_RGB:CNT = ARG_BACK_ARGB / POWER(0x100 , (2 - CNT)) % 0x100
NEXT

SIF INRANGE(L_FRONT_A , 0 , 0xFF) == 0 || INRANGE(L_BACK_A , 0 , 0xFF) == 0 || INRANGE(L_FRONT_RGB , 0 , 0xFFFFFF) == 0 || INRANGE(L_BACK_RGB , 0 , 0xFFFFFF) == 0
	THROW 引数の値がおかしいよ　ARG_FRONT_ARGB=%INT_TO_ARGB(ARG_FRONT_ARGB)%  ARG_BACK_ARGB=%INT_TO_ARGB(ARG_BACK_ARGB)%

IF L_RES_A == 0
	RETURNF 0x0
ELSEIF L_FRONT_A == 0
	RETURNF ARG_BACK_ARGB
;ELSEIF L_BACK_A == 0
;	RETURNF ARG_FRONT_ARGB
ELSEIF L_FRONT_A == 0xFF
	RETURNF ARG_FRONT_ARGB
ENDIF

;それぞれのアルファを比としてかける
FOR CNT , 0 , 3
	L_RES_RGB:CNT = (L_FRONT_A * L_FRONT_RGB:CNT + L_BACK_A * (0xFF - L_FRONT_A) * L_BACK_RGB:CNT / 0xFF + (L_BACK_A * (0xFF - L_FRONT_A) * L_BACK_RGB:CNT % 0xFF > 0xFF / 2 ? 1 # 0))
	L_RES_RGB:CNT = L_RES_RGB:CNT / 0xFF + (L_RES_RGB:CNT % 0xFF > 0xFF / 2 ? 1 # 0)
	L_RES_RGB:CNT = L_RES_RGB:CNT * 0xFF / L_RES_A + (L_RES_RGB:CNT * 0xFF % L_RES_A > 0xFF / 2 ? 1 # 0)
NEXT
RETURNF L_RES_A * 0x1000000 + L_RES_RGB:0 * 0x10000 + L_RES_RGB:1 * 0x100 + L_RES_RGB:2
